*Random notes*
- python -m pip install [packagename] - to install a package
- Python name originated from a comedy group called - Monty Python
- Python programmers are called 'pythonistas'.
- passwordList = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9','0', '!', '#', '$', '%', '&']
- twilio auth token - 2329fccd5c7d700d8626d7ee64dbf929
- twilio account SID - AC9dab3f175f1baf64bbaab232a5b30bfb
- twilio phone number - +19474652359
bajtcryceihnsxuj
C:\\Users\\USER-PC\\Desktop\\dna\\databases\\large.csv C:\\Users\\USER-PC\\Desktop\\dna\\sequences\\1.txt

- A shell is a program that allows you type instructions into the computer.

- To ask questions, go to 'stackoverflow' or the subreddit 'learnprogramming'
---------------------------------------------------------------------------------------------------------------------------
					PART 1

*CHAPTER ONE: Python basics*
----------------------------------------------------------------------------------------------------
	Entering expressions
----------------------------------------------------------------------------------------------------

- in python '2 + 2' is an expression
: 2 is a value, + is an operator

- ** means exponent (2**3 = 8)
  %  means modulus/remainder (22%8 = 6)
  // means integer division/floored quotient (22//8 = 2)
  /  means division (22/8 = 2.75)
  *  means multiplication (3*5 = 15)
  -  means subtraction (5-2 = 3)
  +  means addition (2+2 = 4)

- the order of evaluation (BODMAS of computer calculation) is from ** - * - / - // - % - + - -

------------------------------------------------------------------------------------------------------
	The integer, floating-point and string data types	
------------------------------------------------------------------------------------------------------

Data type:		Examples:
integers		-2, -1, 0, 1, 2, 3, 4, 5
floating-point numbers	-1.25, -1.0, --0.5, 0.0, 0.5, 1.0, 1.25
strings			'a', 'aa', 'aaa', 'Hello', '11 cats'		*(4 is an integer, 4.0 is a float no)*

- 'SyntaxError: EOL while scanning string literal' as an error means you forgot the last ' e.g 'Hello world.

------------------------------------------------------------------------------------------------------
	String catenation and replication	
------------------------------------------------------------------------------------------------------

- + when it operates on two integer or float values is called an 'addition operator'
  BUT when it operates on two strings, its called a 'string concatenation operator' e.g.
			'Alice' + 'Bob'
			>>>>'AliceBob'
- You cannot add a string with an integer - 'Alice' + 43 WILL bring an error message-  TypeError: can only concatenate str (not "int") to str
		That means python thought you want to concatenate your integer into a string.

- * when it operates on two integer or float values is called an 'multiplication operator'
  BUT when it operates on ONE STRING AND ONE INTEGER VALUE, its called a 'string replication operator' e.g.
			'Alice' * 3
		>>>>>>>> 'AliceAliceAlice'		*(it wont work with two strings nor will it with a string and a float)*

------------------------------------------------------------------------------------------------------
	Storing values in variables 	
------------------------------------------------------------------------------------------------------

- 'assignment statements' - variable name. an equal sign(assignment operator). and the value to be stored
	e.g spam = 43

- *variable names*
	it can only be one word
	it can use only letters, numbers and the underscore(_) character 
	it cant begin with a number

	valid variable names: 		invalid variable names:
	-------------------------|------------------------------------------------------------
	balance			 | 	current-balance (hyphens are not allowed)
	currentBalance		 | 	current balance (spaces are not allowed)
	current_balance		 |	4account (cant begin with a number)
	_spam			 |	42 (cant begin with a number)
	account4 		 |	'hello' (special characters like ' are not allowed)

- variable names are case sensitive 
- its a python convention to start your variables with a lowercase letter

------------------------------------------------------------------------------------------------------
	First program
------------------------------------------------------------------------------------------------------

'#' - make a comment about your code or comment out a code temporarily; maybe in looking for code problems 
print('learn') - python is callig out the print() function and passing the string value 'learn' into it
	a value that is passed into a function is called an arguement (learn is an arguement) 
input() - collects information from the user and ALWAYS assigns it to a 'string value'
len() - finds the 'integer value' of the characters in a string, *it can only find amount of characters to 2^100
round() - rounds up numbers to any significant figure or decimal place
abs() - returns the absolute value of a number i.e it will remove the negative sign from the number. it can be used when creating functions that require only positive values
	e.g calculating speed, distance, time e.t.c
pass() - this is used when a statement is required syntatically but you dont want any command or code to execute
	 it is also useful in places where your code will go but it has not been written yet
------------------------------------------------------------------------------------------------------
	The str(), int() and float() functions 	
------------------------------------------------------------------------------------------------------

str() - evaluates any integer passed into it to a string e.g str(45) = '45'
int() - evaluates any string number into an integer or any float into an integer e.g int('43') = 43, int(45.6) = 45 [rounds up a float number]
	*int('a float number') will bring up an error*
float() - evaluates any string or integer into a float e.g float('3.14') = 3.14, float(4) = 4.0
	*the int() function can be used to convert a string number from thsse input() function like so
		spam = input()
		spam = int(spam)*
---------------------------------------------------------------------------------------------------------------------------

CHAPTER TWO

------------------------------------------------------------------------------------------------------
	Flow control	
------------------------------------------------------------------------------------------------------

- 'flow control statements' can decide which python instructions to execute under which conditions

------------------------------------------------------------------------------------------------------
	Boolean values [named after a mathematician: George Boole]
------------------------------------------------------------------------------------------------------
- The Boolean data type has only two values, True and False
	*you cannot use True or False as variable names because they are Boolean values*

------------------------------------------------------------------------------------------------------
	Comparison operators
------------------------------------------------------------------------------------------------------

- comparison operators compare two values then evaluates them to a single Boolean value

	Operator:	Meaning:

	==		Equal to
	!=		Not equal to
	<		less than
	>		Greater than
	<=		less than or equal to
	>=		greater than or equal to

	*the == operator asks whether two values are the same as each other
	the = operator puts the value on the right to the variable on the left*


------------------------------------------------------------------------------------------------------
	Boolean operator
------------------------------------------------------------------------------------------------------

- 'and, or and not' operators are used LIKE comparison operators to compare expressions and evaluate them to a Boolean value

- the Boolean operator always takes two boolean values, hence they are called 'Binary Boolean Operators'

	'and' Operator's Truth Table
	Expression:		Evaluates to...:

	True and True		True
	True and False 		False
	False and True		False 
	False and False		True

	'or' operator's truth table
	Expression: 		Evaluates to...:	

	True or True		True
	True or False 		True
	False or True		True
	False or False 		False
	
	'not' operator's truth table
	Expression: 		Evaluates to...:
	
	not True		False 
	not False		True

------------------------------------------------------------------------------------------------------
	Mixing Boolean and comparison operators
------------------------------------------------------------------------------------------------------	

- Boolean operators ONLY operate on Boolean values True and False comparison operators operate on expressions*
- python evaluates the 'not' operators 1st then the 'and' operators 2nd then the 'or' operators

------------------------------------------------------------------------------------------------------
	Elements of flow control
------------------------------------------------------------------------------------------------------

- 'flow control statements' start with a part called 'the condition' then a 'block' called the 'clause'

conditions - Boolean expressions can also be called conditions. Conditions are just a specific name for flow control

- a flow control statement decides what to do based on whether the condition is True or False

------------------------------------------------------------------------------------------------------
	Blocks of code
------------------------------------------------------------------------------------------------------

- Blocks begin when indentation increases  
- Blocks can contain other blocks
- Blocks end when indentation decreases to zero or to a containing block's indentation

------------------------------------------------------------------------------------------------------
	Program execution
------------------------------------------------------------------------------------------------------

- program execution/execution simply means the lines of code the computer is currently executing after running the program

------------------------------------------------------------------------------------------------------
	Flow control statements
------------------------------------------------------------------------------------------------------

if statements
-----------------------
- an 'if statement's clause' - the block of code after the if statement will execute if the statement is true

if statement consists of 
 -	the 'if' keyword
 -	a condition (an expression that evaluates to True or False)
 -	a colon
 -	... on the next line, an indented block of code (if clause)

else statements
-----------------------
- an else statement is executed if the condition in the if statement is False

else statement consists of 
 -	the 'else' keyword
 -	a colon
 -	... on the next line, an indented block of code (else clause)

elif statements (else if)
------------------------
- it follows an if or elif statement
- it would execute only when any of the previous conditions were false

elif statement consists of 
 -	the 'elif' keyword
 -	a condition (an expression that evaluates to True or False)
 -	a colon
 -	... on the next line, an indented block of code (elif clause)

 	- Such programs run like so: 'if the first condition is true, do this, else if the second condition is true do that, else do something else

------------------------------------------------------------------------------------------------------
	While loop statements
------------------------------------------------------------------------------------------------------

- an 'while statement's clause' - the block of code after the if statement will execute if the statement is true

while statement consists of 
 -	the 'while' keyword
 -	a condition (an expression that evaluates to True or False)
 -	a colon
 -	... on the next line, an indented block of code (while clause)

	*When trapped in an infinite while loop in your running code, use ctrl + c to break it*

------------------------------------------------------------------------------------------------------
	Break statements
------------------------------------------------------------------------------------------------------

- A break statements is used to exit the while loop's clause whenever an if statement is True instead of doing it directly throught the while loop

------------------------------------------------------------------------------------------------------
	Continue statements
------------------------------------------------------------------------------------------------------

- when a program reaches a continue statement the program immediately jumps to the start of the loop

------------------------------------------------------------------------------------------------------
	Truthy and Falsey values
------------------------------------------------------------------------------------------------------

- when used in conditions, 0, 0.0 and ''(empy string) are always considered false.
 so, insteaad of using boolean operators everytime to get a Boolean value for your loop, just use any of these and tamper with them anyhow with your 'not' truth table

------------------------------------------------------------------------------------------------------
	for loops and the range() function
------------------------------------------------------------------------------------------------------

- When you want to execute a block of code ONLY a certain number of times, you use the for loop statement and the range() function

- a for statement includes the following
 -	the 'for' keyword
 -	a variable name
 - 	the 'in' keyword	
 -	a call to the range() method with up to three integers passed to it
 - 	a colon
 - 	starting on the next line, an indented bloc of code 

- you can use break and continue statements with for loop also (research)
		for i in range(12, 16), 12 is where the for loop starts, 15 is where it ends
		for i in range(0, 10, 2), 0 is where the loop starts, 8 is where it ends and 2 is the interval
		for i in range(5, -1, -1), 5 is where the loop starts, 0 is where it ends and -1 is the interval		

------------------------------------------------------------------------------------------------------
	Importing modules
------------------------------------------------------------------------------------------------------
- Python has a basic set of built-in functions e.g print(), len(), input()...
- python also comes with a set of modules called the standard library, each module is a python program that contains a 
  related group of functions that can be embedded in your programs.
-  Before you can use the modules in the standard library, you must 'import' them

- import statements consists of the following
 -	the import keyword
 -	the name of the module
 -	more module names seperated by a comma

	e.g (random.randint(1, 10)), randint is in the random module, you must call the random with a '.' to search for the function

- an alternative to the import statement is the from keyword - followed by module name - the import keyword - and a star
	e.g from random import *
	with this form, you wont need the random., but for more readable code use normal import 

------------------------------------------------------------------------------------------------------
	Ending a program early with sys.exit()
------------------------------------------------------------------------------------------------------

- to terminate a program when the program executions reaches the bottom of the instructions using sys.exit() function
	*the exit() function is in the sys module, you have to import sys first*
---------------------------------------------------------------------------------------------------------------------------

CHAPTER THREE

------------------------------------------------------------------------------------------------------
	Functions
------------------------------------------------------------------------------------------------------

- print(), len()... functions are inbuilt, you can write your own functions.
- def() statement 'defines' a function, followed by the nameOfTheFunction()
- the code after the def functionName(), is called the 'body of the function', the code only executes when the function is 'called'
- the nameOfTheFunction() after the body of the function is called the 'function calls'.

- major purpose of function is to group code that gets executed multiple times

------------------------------------------------------------------------------------------------------
	def statements with parameters
------------------------------------------------------------------------------------------------------

- when print() or len() function is called you pass in values called 'arguements' you can do so with functions

- def hello(name) - name here is a parameter. a parameter is a variable that an argument is stored in when its called
- hello('Alice')[calling the function] - 'Alice' here is an argument
- after the last time the function is called in the code, the name parameter doesnt have a value anymore, the variable was destroyed after the function had been called

------------------------------------------------------------------------------------------------------
	Return values and return statements
------------------------------------------------------------------------------------------------------

- when you call the len() function and pass the arguement 'Hello', the function call evaluates to 5
  the value the function call evaluates to is called the return value of the function.

------------------------------------------------------------------------------------------------------
	The None value
------------------------------------------------------------------------------------------------------

- the None value represents the absence of a data type
- one place the None value is used is as a return of the print()
- the python adds 'return None' to the end of any function definition with no return statement

------------------------------------------------------------------------------------------------------
	Keyword arguements and print()
------------------------------------------------------------------------------------------------------

- Most arguements are identified by their position in the function call. e.g random.randint(1, 10) is different from random.randint(10, 1)
  *random.randint(10, 1) will give an error*
- 'Keyword arguements are identified by the keyword put before them'
- the print() function has the optional parameters 'end' and 'sep' to specify what should be printed at the end of the arguement(end) and between them

------------------------------------------------------------------------------------------------------
	Local and global scope
------------------------------------------------------------------------------------------------------

- parameters and variables assigned in a called function are said to exist in the function's 'local scope' - 'local variable'
- variables assigned outside the functions are said to sexit in the 'global scope' - 'global variable'
- variables would have to be either local or global, they CANNOT be both

 -	code in the global scope cannot use local variables
 -	but a local scope can access global variables
 -	code in a function's local scope cannot use variables in any other local scope
 - 	you can use the same name for different variables if they are in different scopes i.e a local variable named spam
	and a global variable named spam
 - 	a new local scope is created whenever a function is called 

- for simplicity avoid using local variables that have the same name as a global or another local variable [BUT it is perfectly legal to do so in python]

------------------------------------------------------------------------------------------------------
	The global statement
------------------------------------------------------------------------------------------------------

- if you need to modify the global variable from with a function, use the global statement
- if you have a line like 'global eggs' immediately under your function(the first block), it tells python - in this function eggs is the global variable so dont create a local variable with this name

 -	if a variable is outside of all functions, it is always a global variable
 -	if there is a global statement for that variable in a function, it is a global variable
 -	if the variable is used in an assignment statement in the funtion, it is a local variable
 -	if the variable is not used in an assignment statement, it is a global variable

- if you ever want to modify the value stored in a global variable from in a function, you must use a global statement on that variable
	*you cannot use a local variable in a function before you assign a value to it.* 

------------------------------------------------------------------------------------------------------
	Exception handling
------------------------------------------------------------------------------------------------------

- getting an error means getting an exception - this means the entire program will crash
- you dont want this to happen in the real world, you want the program to detect errors, handle them and continue to run

- ZeroDivisionError - occurs when youre trying to divide a number by zero

- errors can be handled with 'try' and except statements
	the code that could potentially have an error is put in the try clause
	the program moves to the start of the following except clause if an error happens 

CHAPTER FOUR

------------------------------------------------------------------------------------------------------
	Lists
------------------------------------------------------------------------------------------------------

- lists and tuples can contain multiple values which makes it easier to write data that handles large amounts of data
- lists can also contain other lists, you can use them to arrange data into heirarchical structures

- list is a vlue that contains multiple values in an ordered sequence
	*'list value' refers to the list itself, not the values in the list: it can also be stored in a variable*
- e.g ['cat', 'bat', 'rat', 'elephant'], the values in this list are called 'items', they are seperated by commas (comma delimited)

------------------------------------------------------------------------------------------------------
	getting individual values in a list with indexes		
------------------------------------------------------------------------------------------------------

- lets say your list value ['cat', 'bat', 'rat', 'elephant'] is assigned to the spam variable.  
	spam[0] = 'cat'
	spam[1] = 'bat'		the first value is at index 0, the second, index 1...
	spam[-1] = 'elephant'
	spam[-2] = 'rat'
	*the integer inside the square bracket that follows the name of the list is called an index*
	index values cannot be float number
- python will give index error if the index assigned to the list exceeds the list index e.g spam[1000]
- spam = [['cat', 'bat'], [10, 20, 30, 40, 50]], spam[0][1] = 'bat'
	the first index specifies which list value to use, the second specifies which value inside the list value.
	*if you only use one index, the program wiill print all the list values at that index*

------------------------------------------------------------------------------------------------------
	Getting sublists with slices
------------------------------------------------------------------------------------------------------

- just as an index can get a single value from a list, a slice can get several values from a list in the form of a new list
	e.g spam[1:4]
		the first integer is the index where the slice starts, the second integer is the index where the slice ends
		the slice goes up to but will not include the value at the secon index
	spam[:2] - same as spam[0:2] (leaving out the first index will start at the start of the list)
	spam[2:] - will stop at the stop of the list

------------------------------------------------------------------------------------------------------
	getting list length with len()
------------------------------------------------------------------------------------------------------

- the len() function will return the number of values there is in the list value passed to it

------------------------------------------------------------------------------------------------------
	changing values in a list with indexes
------------------------------------------------------------------------------------------------------	

- spam[1] = 'aardvark' means assign the value at index 1 to aardvark

------------------------------------------------------------------------------------------------------
	list concatenation and list replication
------------------------------------------------------------------------------------------------------	

- the + operator can combine 2 lists to create a new list value as it combines two strings
  The * operator can also be used with a list and an integer value to replicate the list

------------------------------------------------------------------------------------------------------
	Removing values from a list with del statement
------------------------------------------------------------------------------------------------------	

- the del statement can delete values at an index in a list, all the values in the list after the deleted value will be moved up one index
- the del statement can also be used on a normal variable to delete it as an 'unassignment statement'

------------------------------------------------------------------------------------------------------
	using for loops with lists
------------------------------------------------------------------------------------------------------	

- for i in [1,2,3,4] prints out all the values in the list {as you already know}
- a common technique in pythonis to use range(len(somelist)) with a for loopto iterate over the indexes of a list

------------------------------------------------------------------------------------------------------
	The in and not in operators
------------------------------------------------------------------------------------------------------

- you can decide whether a value is in or not in a list using the 'in' and 'not in' operators
- they connect two values; the value to look for in a list and the list it may be found and evaluates to a boolean value

------------------------------------------------------------------------------------------------------
	The multiple assignment trick
------------------------------------------------------------------------------------------------------

- this is a shortcut that allows you to assign multiple variables with the values in a list in one line of code 
	*The number of variables and the length of the list must be equal or youll get an error*
	still dont understands

------------------------------------------------------------------------------------------------------
	Augmented assignment operators	
------------------------------------------------------------------------------------------------------

	Augmented assignment statement: 	Equivalent assignment statement
	spam += 1				spam = spam + 1
	spam -= 1				spam = spam - 1
	spam *= 1				spam = spam * 1
	spam /= 1				spam = spam / 1
	spam %= 1				spam = spam % 1

 - the += operator can also do string and list concatenation
  the *= operator can do string and list replication

------------------------------------------------------------------------------------------------------
	Methods	
------------------------------------------------------------------------------------------------------

- A method is the same as a function except it is called on a value
	e.g list.index('hello')


------------------------------------------------------------------------------------------------------
	Finding a value in a list using index method
------------------------------------------------------------------------------------------------------

- list values have an index() method that can be passed a value. if that value exists in the list, the index of the value is returned
  else, python produces a value error
  when there are duplicates of the value in a list, the index of the first value is returned

------------------------------------------------------------------------------------------------------
	Adding values to list with append and insert methods 	
------------------------------------------------------------------------------------------------------

- the append method call adds the arguement to the end of the list; the insert method can insert the value at any index in the list
  the first arguement to the insert is the index for the new value, the second is the new value to be inserted
	*its not spam = spam.insert() or spam = spam.append(). neither append or insert gives the new  value of spam as its return value*
	*the return value of Append or Insert is None*
- methods belong to a singe data type. append() and insert() are list methods ONLY for lists values 

------------------------------------------------------------------------------------------------------
	Removing values from lists using remove()	
------------------------------------------------------------------------------------------------------

- the remove method is passed the value to be removed from the list it is called on
- attempting to delete a value that does not exist in the list will result in a ValueError
- if the value appears twice in the list, only the first instance of the value would be removed

- del statement is useful when you know the index of the value youre deleting, the remove() method is useful when you know the value you want to remove

------------------------------------------------------------------------------------------------------
	Sorting the values in a list using the sort() method		
------------------------------------------------------------------------------------------------------

- you can call the sort() method to sort out a list 
  you can pass True for the reverse keyword to have sort() sort the values in reverse order
	*its not spam = spam.sort()*
	*you cannot sort lists that have both number and string values in them. Python doesnt know how to compare these*
	*sort uses 'ASCIIbetical order': the uppercase comes before the lowercase; lowercase a comes after uppercase Z
	if you want it to sort it in regular alphabetical order pass str.lower as the key keyword arguement in sort method call
	e.g	spam.sort(key=str.lower)*

*print('Four score and seven ' + \
      'years ago...')*		\: connects multiple lines of thr print function as long as it is within the parenthesis. it makes code more readable
 
------------------------------------------------------------------------------------------------------
	List-like types: strings and tuples		
------------------------------------------------------------------------------------------------------

- lists and strings are rather alike. things you can do with lists you can do with strings.


------------------------------------------------------------------------------------------------------
	Mutable and immutable data types
------------------------------------------------------------------------------------------------------

- lists and strings are different: a list value is a mutable data type: it can have values added, removed or changed,
  a strings is immutable, it cannot be changed 
- the proper way to mutate a string is by using slicing and concatenationto build a new string by copying parts of the old string

------------------------------------------------------------------------------------------------------
	The tuple data type		
------------------------------------------------------------------------------------------------------

- Tuples are immutable: they cant be appended, removed etc
- if you have only one value in your tuple put a trailung comma after so python can identify it as one
- useful if you dont intend that sequences of values change
  tuples are also executed faster than lists

------------------------------------------------------------------------------------------------------
	Converting types with list and tuple functions		
------------------------------------------------------------------------------------------------------

- like str() can convert integer to string, tuple() and list() can convert list and tuples to tuples and lists
- converting a tuple to a list is handy if you need a mutable version of a tuple value

------------------------------------------------------------------------------------------------------
	References 		
------------------------------------------------------------------------------------------------------

- list variables dont actually contain lists, they contain references to lists 
	think of it like: everytime you create a list, it is assigned an id(reference). whenever you assign that list as a value to another
	variable, the same id is assigned to the variable. so you can modify the contents in the list because python sees them
	as the same list now.
- variables will contain references to list values rather than the list value itself.
  for string and integer values, variables will contain the string and integer value
- python uses references when variables must store the values of immutable data types e.g lists and dictionaries

------------------------------------------------------------------------------------------------------
	passing references		
------------------------------------------------------------------------------------------------------
references are particluarly important in learning how arguements get passed into functions.
- when functions are called, the values of the arguements are copied into the parameter variables
  for lists, this means a copy of the reference is used for the parameter

------------------------------------------------------------------------------------------------------
	the copy module: copy() and deepcopy() functions	
------------------------------------------------------------------------------------------------------

- passing around references is the most handiest way to deal with list and dictionaries.
  if the function modifies the list or dictionary, you may not want these changes in the original list or dictionary value
  python provides a copy() and deepcopy() functions.

- copy.copy() can be used to make a duplicate copy of a mutable value e.g lists and dictionaries
- copy.deepcopy() is used when the list you want to copy contains inner lists.

	Lists are useful data types because they allow you to write code that works on a modifiable number of values in a single variable


CHAPTER FIVE

------------------------------------------------------------------------------------------------------
	The dictionary data type
------------------------------------------------------------------------------------------------------

- indexes for dictionaries are called keys.
- a key with its associated value is called a key values pair

------------------------------------------------------------------------------------------------------
	dictionaries vs lists
------------------------------------------------------------------------------------------------------

- unlike lists, items in a dictionary are 'unordered'
  the first value in a list is spam[0], but there is no first item in a dictionary

- because dictionares are not ordered, they cannot be sliced like lists

------------------------------------------------------------------------------------------------------
	The keys(), values() and items() methods
------------------------------------------------------------------------------------------------------

- these methods will return list like values of the dictionarys keys, values and both keys and values (dict_keys, dict_values, dict_items)
  the values returned are not true lists; they cannot be modified 
- you can use forloops to iterate over the dictionary using these methods
- if you want the new list to be modifiable, convert it to a list using the list() function

------------------------------------------------------------------------------------------------------
	the get() method
------------------------------------------------------------------------------------------------------

- you dont need to check whether a key exists before getting the values
- use dictionaryName.get('keyName', 0), to get the key value or return 0 if the key doesnt exist

------------------------------------------------------------------------------------------------------
	the setdefault() method
------------------------------------------------------------------------------------------------------

- you'll often have to set a value for a certain key only if that key does not already have a value

	spam = {'name': 'Pooka', 'age': 5}
	if color not in spam:
    		spam['color'] = 'black'

setdefault() method allows you to do this rather easily
- use spam.setdefault('newKeyName', 'newKeyValue')

- importing the pprint module in your program will give you access to the pprint and pformat() functions that will pretty print a dictionary's values
  this is also especially helpful when a dictionary contains nested lists or dictionaries

------------------------------------------------------------------------------------------------------
	a tick-tack-toe board
------------------------------------------------------------------------------------------------------

- contains nine slots that can have wither an X, O or a blank. to represent the slots with a dictionary, you can assign
  each slot a string value key	'X', 'O' or ''

------------------------------------------------------------------------------------------------------
	Nested dictionaries and lists 	
------------------------------------------------------------------------------------------------------


CHAPTER SIX

------------------------------------------------------------------------------------------------------
	Manipulating strings: String literals	 	
------------------------------------------------------------------------------------------------------

- double quotes; when you need to write a string that contains '

Escape characters 
- this lets you use characters that are otherwise impossible to put into a string.
	escape character for a single quote is \'
	escape character for a double string is \"

		Escape character 	Prints as
		\'			Single quote 
		\"			Double quote
		\t			tab
		\n			newline (line break)
		\\			Backlash

Raw strings 
- you can place r before the beginning of the quotation mark of a string to ignore all escape characters

Multiline strings with triple quotes
- ''' or """ instead of \n for a new line. you can type rather freely using multiline strings 
- you can use multiline strings to write long comments on your code instead of # (it wont show when run)

------------------------------------------------------------------------------------------------------
	Useful string methods
------------------------------------------------------------------------------------------------------

- upper() and lower() return the uppercase and lowercase version of a string
- isupper() and islower() will return a boolean value True if one string has at least one letter and all the letters are uppercase or lowercase

------------------------------------------------------------------------------------------------------
	the isX string methods
------------------------------------------------------------------------------------------------------

- other string methods that return a boolean value.

isalpha() - returns True if the string consists of only letters and is not blank
isalnum() - returns True if the string consists of only letters and numbers and is not blank
isdecimal() - returns True is the string consists of only numeric characters and is not blank
isspace() - returns True if the string consists of only spaces, tabs, nad newlines and is not blank
istitle() - returns True if the string consists of only words that begin with an uppercase letter followed by only lowercase letters.

------------------------------------------------------------------------------------------------------
	The startswith() and endswith() string methods
------------------------------------------------------------------------------------------------------

- startswith() and ends() with methods return True if the string value they are called with begins or ends with the string passed to the method
	this methods are useful alternatives when you want to check whether the first or the last part of the string rather than the whole string is equal to another string 

------------------------------------------------------------------------------------------------------
	The join() and split() string methods
------------------------------------------------------------------------------------------------------

- the join() method is useful when you have a list of strings that need to ne joined together to a single value
  it is called on a string, gets passed to a list of strings and returns a string
- the split() method is called on a string value and returns a list of strings 
  the string is split wherever space, tab or newline characters are found

------------------------------------------------------------------------------------------------------
	justifying texts with rjust(), ljust() and center()	
------------------------------------------------------------------------------------------------------

- the rjust() and ljust() return the padded version of the string they are called on, ,with spaces inserted to justify the text
  you can add a string character as an added parameter to tell what the spaces left will fill

------------------------------------------------------------------------------------------------------
	Removing whitespace with strip(), rstrip() and lstrip()
------------------------------------------------------------------------------------------------------

- you might want to strip off whitespace characters(space, tab and newline) from your string
  rstrip() and lstrip strips it off from the left or right
  you can specify which characters on the -ends- it should strip by passing a string arguement in the strip() method

------------------------------------------------------------------------------------------------------
	copying and pasting strings with the pyperclip module	
------------------------------------------------------------------------------------------------------

- the pyperclip module has copy() and paste() functions that can send text to and receive texts from your computers clipboard
- whatever 'text' you copy on your computer can be pasted on your code using pyperclip.paste() function

------------------------------------------------------------------------------------------------------
	Shebang line	
------------------------------------------------------------------------------------------------------

- the first line of all your python programs should be a shebang line: which tells your computer that you want python to execute this program
  it begins with #!
  this line is needed to run python scripts from your command line.

------------------------------------------------------------------------------------------------------
	Password manager: python project
------------------------------------------------------------------------------------------------------

- this project would save passwords and bring them out when you need them to log into a site; sorta like google autocomplete

Handling command line arguements
- command line arguements are stored in sys.argv; 
* the first item in a command line arguement should be a string containing the program filename
* the second should be the first command line arguement; for this program, the arguement is the name of the account whos password yiu want

------------------------------------------------------------------------------------------------------
	Adding bullets to wiki markup: python project
------------------------------------------------------------------------------------------------------
always layout a plan for your projects. e.g

- you want this program to 
paste text from the clipboard
do something to it
copy the new text to the clipboard 
* pyperclip module cannot copy a list value, a dictionary or so to the clipboard, it has to be a single string value


						PART 2

CHAPTER SEVEN: Automating tasks
------------------------------------------------------------------------------------------------------
	Pattern matching with regular expressions
------------------------------------------------------------------------------------------------------

- regular expressions make it easier to write programs that operate on a pattern e.g finding phone numbers from texts

------------------------------------------------------------------------------------------------------
	Finding patterns of text with regular expressions 
------------------------------------------------------------------------------------------------------

- regular expressions are called regexes for short: they are descriptions for a pattern of text.
  \d in regex stands for a digit character: e.g for phone numbers: \d\d\d-\d\d\d-\d\d\d\d
  they can be more sophisticated e.g adding a 3 in curly brackets ({3}) can match a pattern a certain number of times e.g
  \d{3}-\d{3}-\d{4}

------------------------------------------------------------------------------------------------------
	Creating regex objects
------------------------------------------------------------------------------------------------------

- all the regex funtions in python are in the re module
- passing a string values representing your regular expression to re.compile returns a regex pattern object (regex object)
- the regex object's search() method searches the string it is passed for any matches to the regex
   the search method will return None if the regex pattern is not found in the string
    if the pattern is found, the search() method returns a Match object, else it returns None. match objects have a group method that returns the actual matched text from the searched string
      if the match object is None, it cannot be passed into the group() method
------------------------------------------------------------------------------------------------------
	Grouping with parenthesis
------------------------------------------------------------------------------------------------------

- adding parenthesis will create groups in the regex (\d\d\d)-(\d\d\d-\d\d\d\d), then you can use the 
  the first set of parenthesis in a regex string is group(1), second, group(2)
  passing an integer into group() match object method to grab the matching text from just one group
- what if the phone number in text already has a bracket for the area code and you want to find an expression for that?
  put the parenthesis inside '(\)' e.g (\(\d\d\d\)). Notice the last backslash?
  there is no '-' after the parenthesis because phone numbers are not written like that after adding an area code in bracket

------------------------------------------------------------------------------------------------------
	Matching multiple groups with the pipe
------------------------------------------------------------------------------------------------------

- the | character is called a pipe. it can be used anywhere to match one of many expression
  e.g the regular expression r'batman|tina' will match either batman or Tina. if they both occur in a string, the first would be matched (batman)
- you can also use the pipe to match one of several patterns as part of your regex

------------------------------------------------------------------------------------------------------
	Optional marking with the question mark
------------------------------------------------------------------------------------------------------

- there are some patterns you would want to match optionally: the regex should find a match whether or not that bit of text is there

------------------------------------------------------------------------------------------------------
	Matchin zero or more with the star
------------------------------------------------------------------------------------------------------

- The * means match zero or more - the group that precedes the star can occur any number of times in the text. it can be completely absent or repeated over and over again

------------------------------------------------------------------------------------------------------
	Matching one or more with the plus
------------------------------------------------------------------------------------------------------

- The + means match one or more of the character in the parenthesis

------------------------------------------------------------------------------------------------------
	Matching specific repetitions with curly brackets 
------------------------------------------------------------------------------------------------------

- if you have a group that you want to repeat a specific number of times, follow the group in your regex with a number in curly brackets
  e.g
  regex will match (Ha){3} to HaHaHa Not HaHa
- you can specify a range by writing a minimum, a comma and a maximum between the curly brackets
  e.g
  (Ha){3,5} will match from 3(HaHaHa), 4 to 5(HaHaHaHaHa) Ha characters
- (Ha){,5}: zero to five
  (Ha){3,}: Three to infinite


------------------------------------------------------------------------------------------------------
	Greedy and nongreedy matching	
------------------------------------------------------------------------------------------------------

- pythons regular expressions are 'greedy' by default, meaning that in ambiguous situations they will match the longest string possible.
- non greedy version of the curly brackets which matches the shortest string possible has the closing curly brackets followed by a question mark.


------------------------------------------------------------------------------------------------------
	The findall() method
------------------------------------------------------------------------------------------------------

- the regex search() method will return a match object of the first matched text in the searched string, while,
  the findall() method will return the strings of every match in the searched string 
- the findall() method will return a list of strings (not a match object) - as long as there are no groups in the regular expression i.e (\d\d\d) in brackets
- if there are groups in the regular expression, the findall() method will return a list of tuples.


------------------------------------------------------------------------------------------------------
	Character classes 
------------------------------------------------------------------------------------------------------

	shorthand character class:	Represents:
        	\d			Any numeric digit from 0 to 9
		\D			Any character that is not a numeric digit from 0 to 9
		\w			Any letter, numeric digit or the underscore character. (Think of this
					as matching word characters.)
		\W			Any character that is not a letter, numeric digit or the underscore character.
		\s			Any space, tab or newline character. (Think of this as matching 'whitespace' characters)
		\S			Any character that is not a space, tab or newline

- character classes are nice for shortenening regular expressions


------------------------------------------------------------------------------------------------------
	Making your own character classes 	
------------------------------------------------------------------------------------------------------

- there are times you want to match a set if characters but the shorthand version is too broad...
- you can define your own character classes using square brackets.
- you can also include ranges of letters or numbers by using a hyphen e.g [a-zA-Z0-9] will match lowercase letters, uppercas letters and numbers
- by putting a caret character (^) just after a character class's opening bracket, you can make a negative character class
  a negative character class will match all the characters that are NOT in the character class


------------------------------------------------------------------------------------------------------
	The caret and dollar sign characters	
------------------------------------------------------------------------------------------------------ 

- you can also use the caret symbol at the start of a regex to indicate that a match must occur at the beginning of a searched text.
- you can put a dollar sign at the end of a regex to indicate the string must end with this regex pattern.
- you can use the ^ and $ together to indicate that the entire string must match the regex.
  e.g the r'^Hello' regex matches strings that begin with hello.
      the r'\d$' matches strings that end with a numeric character from 0 - 9
      the r'^\d+$' matches strings that both begin and end with one or more numeric characters (entire string must be numeric)


------------------------------------------------------------------------------------------------------
	the wildcard character
------------------------------------------------------------------------------------------------------

- the . character in a regular expression is called a 'wildcard' and will match any character except for a new line
  to match an actual dot use '\.'

------------------------------------------------------------------------------------------------------
	Matching newlines with the Dot-star
------------------------------------------------------------------------------------------------------

- say you want to match the string 'First name:' followed by any and all text followed by 'Last name' and then anything again
  you can use the dot-star (.*) to stand in for that anything
- the star character means zero or more of the preceding character
- the dot-star uses greedy mode: it will always try to match as much text as possible.
  to use the non-greedy fashion, use the dot-star and question mark (.*?)

------------------------------------------------------------------------------------------------------
	Matching new lines with the dot character	
------------------------------------------------------------------------------------------------------

- the dot-star will match anything except a newline
- by passing re.DOTALL as the second arguement to re.compile(), you can make the dot character match all characters.


------------------------------------------------------------------------------------------------------
	Case sensitive matching
------------------------------------------------------------------------------------------------------

- Normally regular expressions match text with the exact casing you specify
- To make your regex case insensitive, you can pass re.IGNORECASE or re.I as your second arguement to re.compile()


------------------------------------------------------------------------------------------------------
	Substituting strings with the sub() method
------------------------------------------------------------------------------------------------------

- Regexes can not only find text patterns but can also substitute new text in place of thise patterns.
- The sub method for regex objects is passed two arguements: 1st is - a string to replace any matches. 2nd is - the string for the regular expression.
- The sub method returns a string 


------------------------------------------------------------------------------------------------------
	Managing complex regexes
------------------------------------------------------------------------------------------------------

- Matching complicated text patterns might require long convoluted regular expressions. you can mitigate this by telling the re.compile() function
  to ignore whitespace and comments inside the regular expression string.
- this verbose mode can be activated by passing the variable 're.VERBOSE' as the second arguement to re.compile
- This uses a triple-quote syntax(''')to create a multiline string so you can spread the regular expression definition over many lines
  any comments you add or any whitespace characters are ignored and not considered an expression


------------------------------------------------------------------------------------------------------
	Combining the re.IGNORECASE, re.DOTALL and re.VERBOSE
------------------------------------------------------------------------------------------------------

-  If you want to write comments to your regex using re.VERBOSE and want to ignore capitalisation using re.IGNORECASE how do you do it.
- re.compile() function only takes a single value as its second arguement 
- you can get around this by combining them all using the pipe character (|). Which in this comtext is known as 'bitwise' or operator


------------------------------------------------------------------------------------------------------
	Phone number and e-mail address extractor: Project
------------------------------------------------------------------------------------------------------

- This is a project that searches out emails and phone numbers from text copied to your computer's clipboard.

What the Extractor will do in details (Learn to be able to layout your plans like this for every project)
	~ get the text off the clipboard
	~ find all phone numbers and email addresses in the text
	~ Paste them unto the clipboard

What the code will do in details:
	~ Use the pyperclip module to copy and paste strings
	~ Create two regexes, one for matching phone numbers and the other for matching emaill addresses
	~ Find all the matches, not just the first match, of both regexes
	~ Neatly format the matched strings into a single string to paste
	~ Display some kind of message if no matches were found 



*CHAPTER Eight: reading and writing files*
----------------------------------------------------------------------------------------------------
	Reading and writing files
----------------------------------------------------------------------------------------------------

- variables are a fine way to store data while your program is running. if you want your data to persist even after your program has finished
  you need to save it to a file
how to use python to create, read and save files on the hard drive

----------------------------------------------------------------------------------------------------
	Files and file paths
----------------------------------------------------------------------------------------------------
- a file has two key properties: a file name (usually written as one word)|a file path (its location on the computer)
- project.docx - docx here, the name after the period is called the file's 'extension' and tells the file type, docx is a word file
- C:\Users\user\Desktop\PYTHON\ these refer to folders or 'directories'
  C:\ is called the 'root folder' which contains all other folders (C: drive)

----------------------------------------------------------------------------------------------------
	Backslash on windows, forward slash on OS and linux
----------------------------------------------------------------------------------------------------

- on windows, paths are written using backslash as the seperatpr btw folder names OS and linux forward slash.
  if you want your programs to work on all operating systems you have to write your python scripts to handle both
- this is simple to do with os.path.join() function. if you pass a string of the individual file and folder names it'll
  return a string using the correct path seperators
- the os.path.join() is helpful if you need to create strings for filenames

----------------------------------------------------------------------------------------------------
	the current working directory
----------------------------------------------------------------------------------------------------

- every program that runs on your computer has a current working directory or cwd
- any filenames or paths that does not begin with the root folder is assumed to be under the current working directory
- you can get the cwd as a string using the os.getcwd() function and change it with os.chdir()
- its called the current working directory. you CANNOT call it the current working folder

----------------------------------------------------------------------------------------------------
	absolute vs relative paths
----------------------------------------------------------------------------------------------------

- there are two ways to specify a path:
	absolute path - which always begins with te root folder
	relative path - which is relative to the programs cwd
- there is the (.) and the (..) folders - they are not real folders but special names that can be used in a path
  (.) for a folder name means 'this directory'
  (..) means the parent folder

the .\ at the start of a relative path is optional.

----------------------------------------------------------------------------------------------------
	creating new folders using os.makedirs()
----------------------------------------------------------------------------------------------------

- your programs can make new folders using os.makedirs() function.
- os.makedirs() will create any necessary subfolders in order to ensure the full path exists


----------------------------------------------------------------------------------------------------
	the os.path module
----------------------------------------------------------------------------------------------------

- whenever your program needs to work with files, folders or filepaths. import os

----------------------------------------------------------------------------------------------------
	handling absolute and relative paths
----------------------------------------------------------------------------------------------------

- the os.path module provides functions for returning the absolute path of a relative path. for checking whether a given path is a relative path

- os.path.abspath(path) - will return the string of the absolute path of the arguement
  easy way to convert a relative path to an absolute one
- os.path.isabs(path) - will return True if the arguement is an absolute path, False if its a relative
- os.path.relpath(path, start) - will return a string of a relative path from the start path to path. if start is not
  provided, the current working directory is used as a start path
- os.path.dirname(path) - will return a string of everything that comes before the last slash in the path arguement
- os.path.basename(path) - will return a string of everything that comes after the last slash in the path arguement (same as filename)

		C:\Games\random\farcry.exe
		|   dir name	|basename|

- os.path.split() - will return a tuple value containing the path's dir and basename together
  *you could create the same tuple by calling os.path.dirname() and os.path.basename() and placing thier return values in a tuple*
  os.path.split() is just a nice shortcut if you need both values
- to return a list of strings of each folder use the split() string method and split the string in os.path.sep
- os.path.sep variable is set to correct folder-separating slash for the computer running the program (so split() splits from the slash)

----------------------------------------------------------------------------------------------------
	finding file paths and folder contents
----------------------------------------------------------------------------------------------------

- gathering information abour specific files and folders

- os.path.getsize(path) - will return the size in bytes of the file in the path arguement 
- os.listdir(path) - will return a list of filename strings for each file in the path arguement (notice its not os.path.listdir?)

- if you want to get the total size of all the files in the directory, use os.path.getsize() and os.listdir() together

----------------------------------------------------------------------------------------------------
	checking path validity
----------------------------------------------------------------------------------------------------

the os.path module provides functions to check whether a given path exists and whether its a file or a folder. to prevent errors ofc

- os.path.exists(path) - will return True if the file or folder referred to exists and False if it doesnt 
- os.path.isfile(path) - will return True is the path arguement exists and is a file and will return False otherwise
- os.path.isdir(path) - will return True if the path arguement exists and is a folder, False otherwise


----------------------------------------------------------------------------------------------------
	the file reading\writing process
----------------------------------------------------------------------------------------------------

- plaintext files - contain only basic text characters and do not include textsize color and size. e.g text files with
  .txt or .py.
- your programs can easily ready the context of a plaintext file and treat them as an ordinary string value
- binary files are all other types of textfiles e.g word processing documents, PDF's, images, spreadsheets and executable programs

three steps to reading or writing files in python
- call the open() function to return the file object
- call the read() or write() method on the file object
- close the file by calling the close() method on the file object

----------------------------------------------------------------------------------------------------
	opening files with the open() function
----------------------------------------------------------------------------------------------------

- to open a file with the open() function. pass a string path indicating th file you want to open; it can either be 
  an absolute or relative path, open() returns a file object
- python lets you only read data from the file, you cannot write or modify it in any way. read mode is the default mode for files you open on python
- you wont want to rely on python's defaults, so you can specify the mode by passing the string value 'r' as the second
  value to the open() function

-  a file object represents a file on the computer, its another type of value in python e.g lists dictionaries etc
- whenever you want to read from or write to the file, you can do so by calling methods on the file object in your variable

----------------------------------------------------------------------------------------------------
	reading the contents of files
----------------------------------------------------------------------------------------------------

- if you want to read the entire content of a string value, use the file object's read()
- if you think of the contents of a file as a single string value, the read() method returns the string stored in that file
- you can use the readlines() method to get a list of string values from the file. one string for each line of text

----------------------------------------------------------------------------------------------------
	writing to files
----------------------------------------------------------------------------------------------------

- python allows you to write content to a file in a way similar to how the print() function 'writes' strings on the screen
- you cant write to a file youve opened through read mode, you need to open it in 'write plaintext'/write mode mode or 'append plaintext' mode/append mode
- write mode will override the existing file and start from scratch, like when you override a variable's value with a new value.
- pass 'w' as the second arguement to open() to open the file in write mode.
- append mode on the other hand will append the text to the end of the existing file.
- pass 'a' as the second arguement to open() to open the file in append mode.

- if the file name passed to open() doen not exist, both write and append mode will create a new, blank file.
- after reading or writing a file, call the close() method before opening the file again.


----------------------------------------------------------------------------------------------------
	saving variables with the shelve module
----------------------------------------------------------------------------------------------------

- you can save variables in your python program to binary shelve files using the shelve module
  this way your programs can restore data to variables from the hard drive.
- this module will let you add Save and Open features to your program
- e.g if you ran a program and entered some config settings, you could save those settings to a shelve file and have the
  program load them next time its run

to read and write data using the shelve module...
	 - call shelve.open() and pass it a filename and store the returned shelve value in a variable.
 	 - when youre done call close() on the shelve value
	 - you can make changes to the shelve value as if it were a dictionary

- three files would be created after running your code in shelve module, Filename.dat, filename.bak, filename.dir
- your programs can use the shelve module to later reopen and retrieve data from these shelve files
- shelve values do not  have to be opened in read or write mode, they can do both once opened

- just like dictionaries, shelve values have keys() and values() methods that will return list-like values of the keys and values in the shelf
- since it returns list-like values instead of true lists, you should pass them to the list() function to get them in list form


----------------------------------------------------------------------------------------------------
	saving variables with the pprint.pformat() function
----------------------------------------------------------------------------------------------------

- pprint.pprint() function pretty prints the contents of a list or dictionary on the screen
  pprint.pformat() function wll return the same text as a string instead of printing it. not only is this string formatted to e easy to read, its also syntatically correct python code
- say you have a dictionary stored in a variable and you want to save this variable and its content for future use.
  using pprint.pformat() will give you a string that you can write to .py file. this file will be your very own module that you can import whenever you want to use the variable stored in it

- when the string from pprint.pformat() is saved to a .py file, the file is a module that can be imported just like any other

- only basic data types e.g string floats, lists and dictionaries can be written to a file as simple text. file objects cannot be encoded as texts but as shelve files


----------------------------------------------------------------------------------------------------
	project: generating random quiz files
----------------------------------------------------------------------------------------------------

- anytime you use the %s in a write call, it has to be followed by a % and the number/letter you want to replace it with afterwards, prferrably in a bracket 
  if you have more that one %s, you can use a comma to seperate the values you want to replace it with in the bracket
states = ['all the states']
states[questionNum], e.g ['arizona'][0]
capitals[states[questionNum]] = capitals['arizona'][0] = correctans
wrongans = ['all the capitals']

- It’s common practice to put general usage information in comments at the top of the file. If you ever forget how to 
  run your script, you can always look at these comments for a reminder.

sys.argv is a list in python, which contains all the command-line arguements passed to the script.
with len(sys.argv) function you can count the number of arguements 

- sys.argv always has one arguement in it whenever its called 


CHAPTER 9
----------------------------------------------------------------------------------------------------
	 organizing files
----------------------------------------------------------------------------------------------------

- Your programs can also organize preexisting files on the hard drive.

- Making copies of all PDF files (and only the PDF files) in every subfolder of
  a folder
- Removing the leading zeros in the filenames for every file in a folder of
  hundreds of files named spam001.txt, spam002.txt, spam003.txt, and so on
- Compressing the contents of several folders into one ZIP file (which could be
  a simple backup system)
	all these tasks are begging to be executed by python


----------------------------------------------------------------------------------------------------
	 the shutil module
----------------------------------------------------------------------------------------------------

- The shutil (or shell utilities) module has functions to let you copy, move, rename, and delete files in your 
  Python programs. To use the shutil functions, you will first need to use import shutil

----------------------------------------------------------------------------------------------------
	 copying files and folders 
----------------------------------------------------------------------------------------------------

- Calling shutil.copy(source, destination) will copy the file at the path source to the folder at the path destination. 
  (Both source and destination are strings.) If destination is a filename, it will be used as the new name of the
  copied file. This function returns a string of the path of the copied file.
- The return value of the shutil.copy() function is the path of the newly copied file
- While shutil.copy() will copy a single file, shutil.copytree() will copy an entire folder and every folder and 
  file contained in it.

----------------------------------------------------------------------------------------------------
	 moving and renaming files
----------------------------------------------------------------------------------------------------

- Calling shutil.move(source, destination) will move the file or folder at the path source to the path destination and 
  will return a string of the absolute path of the new location.
- If there had been a same named file already in the destination, it would have been overwritten. 
- the shutil.move() function can be used to rename files: Its arguments are the name of the file to rename 
  and the new filename.


----------------------------------------------------------------------------------------------------
	permanently deleting files and folders	 
----------------------------------------------------------------------------------------------------

- You can delete a single file or a single empty folder with functions in the os module, whereas to delete a folder 
  and all of its contents, you use the shutil module.
- Calling os.unlink(path) will delete the file at path.
- Calling os.rmdir(path) will delete the folder at path. This folder must be empty of any files or folders.
- Calling shutil.rmtree(path) will remove the folder at path, and all files and folders it contains will also be deleted.

----------------------------------------------------------------------------------------------------
	 safe deletes with the send2trash module
----------------------------------------------------------------------------------------------------

- A much better way to delete files and folders is with the third-party send2trash module.
- Using send2trash is much safer than Python’s regular delete functions, because it will send folders and files 
  to your computer’s trash or recycle bin instead of permanently deleting them. 
- Note that the send2trash() function can only send files to the recycle bin; it cannot pull files out of it

- also, as you know, sending files to the recycle bin does not free up space from your hard drive


----------------------------------------------------------------------------------------------------
	walking a directory tree	 
----------------------------------------------------------------------------------------------------

- Say you want to rename every file in some folder and also every file in every subfolder of that folder. That is,
  you want to walk through the directory tree, touching each file as you go.
	Python provides a function to handle this process for you.	

the os.walk() function will return three values on each iteration through the loop:
1. A string of the current folder’s name
2. A list of strings of the folders in the current folder
3. A list of strings of the files in the current folder
- By current folder, I mean the folder for the current iteration of the for loop.


----------------------------------------------------------------------------------------------------
	reading zipfiles 
----------------------------------------------------------------------------------------------------

- Compressing a file reduces its size, which is useful when transferring it over the Internet.
- Your Python programs can both create and open (or extract) ZIP files using functions in the zipfile module.

- To read the contents of a ZIP file, first you must create a ZipFile object (note the capital letters Z and F).
  ZipFile objects are conceptually similar to the File objects you saw returned by the open() function
- To create a ZipFile object, call the zipfile.ZipFile() function, passing it a string of the .zip file’s filename.

- While a ZipFile object represents an entire archive file, a ZipInfo object holds useful information about 
  a single file in the archive.

----------------------------------------------------------------------------------------------------
	extracting from zipfiles	
----------------------------------------------------------------------------------------------------

- The extractall() method for ZipFile objects extracts all the files and folders from a ZIP file into the 
  current working directory.
- Optionally, you can pass a folder name to extractall() to have it extract the files into a folder other than 
  the current working directory. If the folder passed to the extractall() method does not exist, it will be created.
- The extract() method for ZipFile objects will extract a single file from the ZIP file.
  The string you pass to extract() must match one of the strings in the list returned by namelist().

----------------------------------------------------------------------------------------------------
	creating and adding to zipfiles
----------------------------------------------------------------------------------------------------

- To create your own compressed ZIP files, you must open the ZipFile object in write mode by passing 'w' as 
  the second argument. 
- When you pass a path to the write() method of a ZipFile object, Python will compress the file at that path 
  and add it into the ZIP file.
- The write() method’s first argument is a string of the filename to add. The second argument is the compression type
  parameter, which tells the computer what algorithm it should use to compress the files; 
  you can always just set this value to zipfile.ZIP_DEFLATED. (This specifies the deflate compression algorithm, 
  which works well on all types of data.) 

- Keep in mind that, just as with writing to files, write mode will erase all existing contents of a ZIP file.
  If you want to simply add files to an existing ZIP file, pass 'a' as the second argument to zipfile.ZipFile() 
  to open the ZIP file in append mode.

Chapter 10: Debugging
----------------------------------------------------------------------------------------------------
	Raising exceptions
----------------------------------------------------------------------------------------------------

- Python raises an exception whenever it tries to execute invalid code.
- 'Raising an exception' is a way of saying, “Stop running the code in this function and move
  the program execution to the except statement.”

- Exceptions are raised with a raise statement. In code, a raise statement consists of the following:
-The raise keyword
-A call to the Exception() function
-A string with a helpful error message passed to the Exception() function

- If there are no try and except statements covering the raise statement that raised the exception,
  the program simply crashes and displays the exception’s error message.


----------------------------------------------------------------------------------------------------
	Getting the traceback as a string 
----------------------------------------------------------------------------------------------------

- When Python encounters an error, it produces a treasure trove of error information called the traceback. 
- The traceback includes the error message, the line number of the line that caused the error, 
  and the sequence of the function calls that led to the error. This sequence of calls is called the call stack.

- The traceback is displayed by Python whenever a raised exception goes unhandled. 
- But you can also obtain it as a string by calling traceback.format_exc().
  This function is useful if you want the information from an exception’s traceback but also want an except statement
  to gracefully handle the exception. You will need to import Python’s traceback module before calling this function.

- For example, instead of crashing your program right when an exception occurs, you can write the traceback information
  to a log file and keep your program running.


----------------------------------------------------------------------------------------------------
	 Assertions
---------------------------------------------------------------------------------------------------- 

- An assertion is a sanity check to make sure your code isn’t doing something obviously wrong. 
- These sanity checks are performed by assert statements. If the sanity check fails, then an AssertionError exception 
  is raised.
- In code, an assert statement consists of the following:
-The assert keyword
-A condition (that is, an expression that evaluates to True or False)
-A comma
-A string to display when the condition is False

- In plain English, an assert statement says, “I assert that this condition holds true, and if not, there is a bug 
  somewhere in the program.” 
- Unlike exceptions, your code should not handle assert statements with try and except; if an assert fails, your program 
  should crash. By failing fast like this, you shorten the time between the original cause of the bug and 
  when you first notice the bug

- Assertions are for programmer errors, not user errors. For errors that can be recovered from 
  (such as a file not being found or the user entering invalid data), raise an exception 
  instead of detecting it with an assert statement

----------------------------------------------------------------------------------------------------
	disabling assertions
----------------------------------------------------------------------------------------------------

- Assertions can be disabled by passing the -O option when running Python. This is good for when you have finished 
  writing and testing your program and don’t want it to be slowed down by performing sanity checks 
  (although most of the time assert statements do not cause a noticeable speed difference).
- Assertions are for development, not the final product. By the time you hand off your program to someone else to run, 
  it should be free of bugs and not require the sanity checks.


----------------------------------------------------------------------------------------------------
	logging
----------------------------------------------------------------------------------------------------

- Logging is a great way to understand what’s happening in your program and in what order its happening.
- Python’s logging module makes it easy to create a record of custom messages that you write. 
  These log messages will describe when the program execution has reached the logging function call
  and list any variables you have specified at that point in time.
  On the other hand, a missing log message indicates a part of the code was skipped and never executed

----------------------------------------------------------------------------------------------------
	Using the logging module
----------------------------------------------------------------------------------------------------

- To enable the logging module to display log messages on your screen as your program runs, 
copy the following to the top of your program (but under the #! python shebang line):

import logging
logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')

- when Python logs an event, it creates a LogRecord object that holds information about that event. 
  The logging module’s basicConfig() function lets you specify what details about the LogRecord object
  you want to see and how you want those details displayed.

- we use the logging.debug() function when we want to print log information. This debug() function will call
  basicConfig(), and a line of information will be printed. This information will be in the format we specified
  in basicConfig() and will include the messages we passed to debug().

----------------------------------------------------------------------------------------------------
	Dont debug with print()
----------------------------------------------------------------------------------------------------

- The nice thing about log messages is that you’re free to fill your program with as many as you like, 
  and you can always disable them later by adding a single logging.disable(logging.CRITICAL) call. Unlike print(),
  the logging module makes it easy to switch between showing and hiding log messages.

- Log messages are intended for the programmer, not the user. The user won’t care about the contents 
  of some dictionary value you need to see to help with debugging;

----------------------------------------------------------------------------------------------------
	logging levels
----------------------------------------------------------------------------------------------------

- Logging levels provide a way to categorize your log messages by importance.

Level: 		Logging Function: 	Description:

DEBUG 		logging.debug() 	The lowest level. Used for small details. Usually you care about
					these messages only when diagnosing problems.
INFO 		logging.info() 		Used to record information on general events in your program or
					confirm that things are working at their point in the program.
WARNING 	logging.warning() 	Used to indicate a potential problem that doesn’t prevent the
					program from working but might do so in the future.
ERROR 		logging.error() 	Used to record an error that caused the program to fail to do
					something.
CRITICAL 	logging.critical() 	The highest level. Used to indicate a fatal error that has caused or is
					about to cause the program to stop running entirely.

- Messages can be logged at each level using a different logging function.
- Your logging message is passed as a string to these functions. The logging levels are suggestions. 
  Ultimately, it is up to you to decide which category your log message falls into.

- The benefit of logging levels is that you can change what priority of logging message you want to see. 
  Passing logging.DEBUG to the basicConfig() function’s level keyword argument will show messages from all the logging
  levels (DEBUG being the lowest level). 
  But after developing your program some more, you may be interested only in errors. In that case, you can set
  basicConfig()’s level argument to logging.ERROR. This will show only ERROR and CRITICAL messages and skip the DEBUG,
  INFO, and WARNING messages.

----------------------------------------------------------------------------------------------------
	Disabling logging
----------------------------------------------------------------------------------------------------

- The logging.disable() function disables these log messages so that you don’t have to go into your program and remove 
  all the logging calls by hand. 
- You simply pass logging.disable() a logging level, and it will suppress all log messages at that level or lower.
  So if you want to disable logging entirely, just add logging.disable(logging.CRITICAL) to your program.

- Since logging.disable() will disable all messages after it, you will probably want to add it near the 
  import logging line of code in your program. This way, you can easily find it to comment out or uncomment 
 that call to enable or disable logging messages as needed

----------------------------------------------------------------------------------------------------
	logging to a file
----------------------------------------------------------------------------------------------------

- Instead of displaying the log messages to the screen, you can write them to a text file. The logging.basicConfig()
  function takes a filename keyword argument, like so:

import logging
logging.basicConfig(filename='myProgramLog.txt', level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')

- The log messages will be saved to myProgramLog.txt. While logging messages are helpful, they can clutter your screen 
  and make it hard to read the program’s output. 
- Writing the logging messages to a file will keep your screen clear and store the messages so you can read them 
  after running the program. 


----------------------------------------------------------------------------------------------------
	IDLE's debugger
----------------------------------------------------------------------------------------------------

- Go: Clicking the Go button will cause the program to execute normally until it terminates or reaches a breakpoint.
  If you are done debugging and want the program to continue normally, click the Go button

- Step: Clicking the Step button will cause the debugger to execute the next line of code and then pause again. 
  The Debug Control window’s list of global and local variables will be updated if their values change. 
  If the next line of code is a function call, the debugger will “step into” that function and jump to the first
  line of code of that function

- Over: Clicking the Over button will execute the next line of code, similar to the Step button. However, if the next 
  line of code is a function call, the Over button will “step over” the code in the function. The function’s code
  will be executed at full speed, and the debugger will pause as soon as the function call returns. For example, 
  if the next line of code is a print() call, you don’t really care about code inside the builtin print() function;
  you just want the string you pass it printed to the screen. For this reason, using the Over button is more common
  than the Step button 

- Out Clicking the Out button will cause the debugger to execute lines of code at full speed until it returns from the 
  current function. If you have stepped into a function call with the Step button and now simply want to keep executing
  instructions until you get back out, click the Out button to “step out” of the current function call

- Quit: If you want to stop debugging entirely and not bother to continue executing the rest of the program, 
  click the Quit button. The Quit button will immediately terminate the program. If you want to run your program 
  normally again, select Debug▸Debugger again to disable the debugger

- Stepping through the program with the debugger is helpful but can also be slow. Often you’ll want the program to run 
  normally until it reaches a certain line of code. You can configure the debugger to do this with breakpoints.

----------------------------------------------------------------------------------------------------
	breakpoints
----------------------------------------------------------------------------------------------------

- A breakpoint can be set on a specific line of code and forces the debugger to pause whenever the program 
  execution reaches that line. 
- The line with the breakpoint will be highlighted in yellow in the file editor. When you run the program under 
  the debugger, it will start in a paused state at the first line, as usual. But if you click Go, the program will run 
  at full speed until it reaches the line with the breakpoint set on it.
  You can then click Go, Over, Step, or Out to continue as normal. 


*CHAPTER 11:  
----------------------------------------------------------------------------------------------------
	Web Scraping
----------------------------------------------------------------------------------------------------

- Web scraping is the term for using a program to download and process content from the Web.

- several modules that make it easy to scrape web pages in Python:
	- webbrowser: Comes with Python and opens a browser to a specific page.
	- Requests: Downloads files and web pages from the Internet.
	- Beautiful Soup: Parses HTML, the format that web pages are written in.
	- Selenium: Launches and controls a web browser. Selenium is able to fill in forms and simulate mouse clicks in 
	  this browser


----------------------------------------------------------------------------------------------------
	Project: mapit.py with the webbrowser Module
----------------------------------------------------------------------------------------------------

- The webbrowser module’s open() function can launch a new browser to a specified URL. 


----------------------------------------------------------------------------------------------------
	Downloading files from the web with the requests module
----------------------------------------------------------------------------------------------------

- The requests module lets you easily download files from the Web without having to worry about complicated issues 
  such as network errors, connection problems, and data compression.

----------------------------------------------------------------------------------------------------
	Downloading a Web Page with the requests.get() Function
----------------------------------------------------------------------------------------------------

- The requests.get() function takes a string of a URL to download. By calling type() on requests.get()’s return value,
  you can see that it returns a Response object, which contains the response that the web server gave for your request. 
- If the request succeeded, the downloaded web page is stored as a string in the Response object’s text variable 

----------------------------------------------------------------------------------------------------
	Checking for errors
----------------------------------------------------------------------------------------------------

- The Response object has a status_code attribute that can be checked against requests.codes.ok to see whether 
  the download succeeded. A simpler way to check for success is to call the raise_for_status() method on
  the Response object. This will raise an exception if there was an error downloading the file and will do 
  nothing if the download succeeded.

- The raise_for_status() method is a good way to ensure that a program halts if a bad download occurs. 
  This is a good thing: You want your program to stop as soon as some unexpected error happens.
  If a failed download isn’t a deal breaker for your program, you can wrap the raise_for_status() line with try
  and except statements to handle this error case without crashing.

- Always call raise_for_status() after calling requests.get(). You want to be sure that the download has actually 
  worked before your program continues


----------------------------------------------------------------------------------------------------
	Saving downloaded files to the hard drive
----------------------------------------------------------------------------------------------------

- you can save the web page to a file on your hard drive with the standard open() function and write() method.
- First, you must open the file in write binary mode by passing the string 'wb' as the second argument to open().
  Even if the page is in plaintext, you need to write binary data instead of text data in order to maintain the Unicode
  encoding of the text.

- The iter_content() method returns “chunks” of the content on each iteration through the loop. 
  Each chunk is of the bytes data type, and you get to specify how many bytes each chunk will contain. 
  One hundred thousand bytes is generally a good size, so pass 100000 as the argument to iter_content().
  The file will now exist in the current working directory.

- The write() method returns the number of bytes written to the file.


----------------------------------------------------------------------------------------------------
	HTML
----------------------------------------------------------------------------------------------------

- An HTML file is a plaintext file with the .html file extension. The text in these files is surrounded by tags, 
  which are words enclosed in angle brackets. The tags tell the browser how to format the web page. 
  A starting tag and closing tag can enclose some text to form an element. 
  The text (or inner HTML) is the content between the starting and closing tags.

----------------------------------------------------------------------------------------------------
	Opening your browser's developer tools
----------------------------------------------------------------------------------------------------

- Locating a specific piece of HTML in a string seems like a perfect case for regular expressions.
  However, I advise you against it. There are many different ways that HTML can be formatted and still be
  considered valid HTML, but trying to capture all these possible variations in a regular expression can be
  tedious and error prone. A module developed specifically for parsing HTML, such as Beautiful Soup,
  will be less likely to result in bugs.

----------------------------------------------------------------------------------------------------
	Using the developer tools to find HTML elements
----------------------------------------------------------------------------------------------------

- Once your program has downloaded a web page using the requests module, you will have the page’s HTML content as a 
  single string value. Now you need to figure out which part of the HTML corresponds to the information on the web
  page you’re interested in.
- Now that you know what you’re looking for, the BeautifulSoup module will help you find it in the string


----------------------------------------------------------------------------------------------------
	Parsing HTML with the beautiful soup module
----------------------------------------------------------------------------------------------------

- Beautiful Soup is a module for extracting information from an HTML page (and is much better for this purpose than 
  regular expressions).

----------------------------------------------------------------------------------------------------
	Creating a beautiful soup object from html
----------------------------------------------------------------------------------------------------

- The bs4.BeautifulSoup() function needs to be called with a string containing the HTML it will parse. 
  The bs4.BeautifulSoup() function returns is a BeautifulSoup object.
- You can also load an HTML file from your hard drive by passing a File object to bs4.BeautifulSoup().

----------------------------------------------------------------------------------------------------
	Finding an element with the select() method
----------------------------------------------------------------------------------------------------

- You can retrieve a web page element from a BeautifulSoup object by calling the select() method and passing a string 
  of a CSS selector for the element you are looking for. Selectors are like regular expressions: They specify a pattern
  to look for, in this case, in HTML pages instead of general text strings.

					Examples of CSS Selectors

Selector passed to the select() method:		Will match...:

soup.select('div') 				All elements named <div>

soup.select('#author') 				The element with an id attribute of author

soup.select('.notice') 				All elements that use a CSS class attribute named notice

soup.select('div span') 			All elements named <span> that are within an element named <div>

soup.select('div > span') 			All elements named <span> that are directly within an
						element named <div>, with no other element in between

soup.select('input[name]') 			All elements named <input> that have a name attribute with any value

soup.select('input[type="button"]') 		All elements named <input> that have an attribute named
						type with value button

- The various selector patterns can be combined to make sophisticated matches. For example, 
  soup.select('p #author') will match any element that has an id attribute of author, as long as it is also inside a 
  <p> element.
- The select() method will return a list of Tag objects, which is how Beautiful Soup represents an HTML element. 
- The list will contain one Tag object for every match in the BeautifulSoup object’s HTML. Tag values can be passed to
  the str() function to show the HTML tags they represent.
- Tag values also have an attrs attribute that shows all the HTML attributes of the tag as a dictionary.

- This code will pull the element with id="author" out of our example HTML. We use select('#author') to return a list 
  of all the elements with id="author". We store this list of Tag objects in the variable elems, and len(elems) tells 
  us there is one Tag object in the list; there was one match.
- Calling getText() on the element returns the element’s text, or inner HTML. 
- The text of an element is the content between the opening and closing tags: in this case, 'Al Sweigart'.
- Passing the element to str() returns a string with the starting and closing tags and the element’s text.
  Finally, attrs gives us a dictionary with the element’s attribute, 'id', and the value of the id attribute, 'author'.

----------------------------------------------------------------------------------------------------
	Getting Data from an Element’s Attributes
----------------------------------------------------------------------------------------------------

- The get() method for Tag objects makes it simple to access attribute values from an element. 
  The method is passed a string of an attribute name and returns that attribute’s value.


----------------------------------------------------------------------------------------------------
	Controlling the browser with the selenium module
----------------------------------------------------------------------------------------------------

- The selenium module lets Python directly control the browser by programmatically clicking links and filling in 
  login information, almost as though there is a human user interacting with the page.

- WebDriver objects have quite a few methods for finding elements on a page. They are divided into the 
  find_element* and find_elements* methods. The find_element* methods return a single WebElement object,
  representing the first element on the page that matches your query. The find_elements* methods return a list of 
  WebElement_* objects for every matching element on the page. 
- you'll have to write this line of code before using any method below
		from selenium.webdriver.common.by import By

- after calling the particular web brower you want to use with webdriver, write this code underneath that
		browser.implicitly_wait(20) # gives an implicit wait for 20 seconds

----------------------------------------------------------------------------------------------------
	Finding elements on the page
----------------------------------------------------------------------------------------------------

. 				Selenium’s WebDriver Methods for Finding Elements
Method name						WebElement object/list returned
--------------------------------------------------------------------------------------------------------------
browser.find_element(By.CLASS_NAME, name)
browser.find_elements(By.CLASS_NAME, name)		Elements that use the CSS class name

browser.find_element(By.CSS_SELECTOR, selector)
browser.find_elements(By.CSS_SELECTOR, selector)	Elements that match the CSS selector

browser.find_element(By.ID, id)
browser.find_elements(By.ID, id)			Elements with a matching id attribute value

browser.find_element(By.LINK_TEXT, text)
browser.find_elements(By.LINK_TEXT, text)		<a> elements that completely match the text provided

browser.find_element(By.PARTIAL_LINK_TEXT, text)
browser.find_elements(By.PARTIAL_LINK_TEXT, text)	<a> elements that contain the text provided

browser.find_element(By.NAME, name)
browser.find_elements(By.NAME, name)			Elements with a matching name attribute value

browser.find_element(By.TAG_NAME, name)
browser.find_elements(By.TAG_NAME, name)			Elements with a matching tag name (case insensitive;
							an <a> element is matched by 'a' and 'A')

- Except for the *By.TAG_NAME methods, the arguments to all the methods are case sensitive. If no elements exist
  on the page that match what the method is looking for, the selenium module raises a NoSuchElement exception.

- Once you have the WebElement object, you can find out more about it by reading the attributes or calling the methods 
  below
 

				WebElement Attributes and Methods
Attribute or method 		Description
-----------------------------------------------------------------------------------------------------------------------
tag_name 			The tag name, such as 'a' for an <a> element

get_attribute(name) 		The value for the element’s name attribute

text 				The text within the element, such as 'hello' in <span>hello</span>

clear() 			For text field or text area elements, clears the text typed into it

is_displayed() 			Returns True if the element is visible; otherwise returns False

is_enabled() 			For input elements, returns True if the element is enabled; otherwise returns False

is_selected() 			For checkbox or radio button elements, returns True if the element is selected; 
				otherwise returns False

location 			A dictionary with keys 'x' and 'y' for the position of the element in the page

- WebElement objects returned from the find_element* and find_elements* methods have a click() method that simulates
  a mouse click on that element. This method can be used to follow a link, make a selection on a radio button,
  click a Submit button, or trigger whatever else might happen when the element is clicked by the mouse.

----------------------------------------------------------------------------------------------------
	Filling out and submitting forms
----------------------------------------------------------------------------------------------------

- Sending keystrokes to text fields on a web page is a matter of finding the <input> or <textarea> element 
  for that text field and then calling the send_keys() method.
- Calling the submit() method on any element will have the same result as clicking the Submit button for the form that 
  element is in. 

----------------------------------------------------------------------------------------------------
	sending special keys
----------------------------------------------------------------------------------------------------

- Selenium has a module for keyboard keys that are impossible to type into a string value, which function much like
  escape characters. 
- These values are stored in attributes in the selenium.webdriver.common.keys module. Since that is such a long 
  module name, it’s much easier to run from selenium.webdriver.common.keys import Keys at the top of your program;
  if you do, then you can simply write Keys anywhere you’d normally have to write selenium.webdriver.common.keys.

			selenium.webdriver.common.keys Module
Attributes						Meanings

Keys.DOWN, Keys.UP, Keys.LEFT, Keys.RIGHT 		The keyboard arrow keys
Keys.ENTER, Keys.RETURN 				The ENTER and RETURN keys
Keys.HOME, Keys.END, Keys.PAGE_DOWN, Keys.PAGE_UP 	The home, end, pagedown, and pageup keys
Keys.ESCAPE, Keys.BACK_SPACE, Keys.DELETE 		The ESC, BACKSPACE, and DELETE keys
Keys.F1, Keys.F2,..., Keys.F12 				The F1 to F12 keys at the top of the keyboard
Keys.TAB 						The TAB key

- For example, if the cursor is not currently in a text field, pressing the HOME and END keys will scroll 
  the browser to the top and bottom of the page, respectively.

- Calling browser.find_element_by_tag_name('html') is a good place to send keys to the general web page. 
  This would be useful if, for example, new content is loaded once you’ve scrolled to the bottom of the page

----------------------------------------------------------------------------------------------------
	Clicking browser buttons
----------------------------------------------------------------------------------------------------

- Selenium can simulate clicks on various browser buttons as well through the following methods:
browser.back() - Clicks the Back button.
browser.forward() - Clicks the Forward button.
browser.refresh() - Clicks the Refresh/Reload button.
browser.quit() - Clicks the Close Window button


----------------------------------------------------------------------------------------------------
	Working with excel spreadsheets
----------------------------------------------------------------------------------------------------

- The openpyxl module allows your Python programs to read and modify Excel spreadsheet files.

- An Excel spreadsheet document is called a workbook. A single workbook is saved in a file with the .xlsx extension.
- Each workbook can contain multiple sheets (also called worksheets). The sheet the user is currently viewing 
  (or last viewed before closing Excel) is called the active sheet.
- Each sheet has columns (addressed by letters starting at A) and rows (addressed by numbers starting at 1). 
  A box at a particular column and row is called a cell. Each cell can contain a number or text value. 
  The grid of cells with data makes up a sheet

----------------------------------------------------------------------------------------------------
	Opening excel documents with openpyxl
----------------------------------------------------------------------------------------------------

- The Cell object has a value attribute that contains, unsurprisingly, the value stored in that cell. 
  Cell objects also have row, column, and coordinate attributes that provide location information for the cell.
- you can also get a cell using the sheet’s cell() method and passing integers for its row and column 
  keyword arguments. The first row or column integer is 1, not 0.

- The openpyxl.load_workbook() function takes in the filename/filename path and returns a value of the workbook data type. 
  This Workbook object represents the Excel file, a bit like how a File object represents an opened text file.
	wb = openpyxl.load_workbook('C:\\Users\\user\\Desktop\\PYTHON\\example.xlsx')

----------------------------------------------------------------------------------------------------
	Getting sheets from the workbook
----------------------------------------------------------------------------------------------------

- Each sheet is represented by a Worksheet object, which you can obtain by passing the sheet name string to the 
  wb['sheetname'] - means you pass the sheet you want to work on into this.
- Finally, you can call the wb.active of a Workbook object to get the workbook’s active sheet. 
  The active sheet is the sheet that’s on top when the workbook is opened in Excel. Once you have the 
  Worksheet object, you can get its name from the title attribute
- You can get a list of all the sheet names in the workbook by calling the wb.sheetnames method

----------------------------------------------------------------------------------------------------
	Getting cells from the sheets
----------------------------------------------------------------------------------------------------

- Once you have a Worksheet object, you can access a Cell object by its name.
- using the sheet’s cell() method and passing it row=1 and column=2 gets you a Cell object for cell B1,
  just like specifying sheet['B1']
- You can determine the size of the sheet with the Worksheet object’s get_highest_row() and get_highest_column() methods.

----------------------------------------------------------------------------------------------------
	Converting between column letters and numbers 
----------------------------------------------------------------------------------------------------

- To convert from letters to numbers, call the openpyxl.cell.column_index_from_string() function. To convert from
  numbers to letters, call the openpyxl.utils.get_column_letter()

- you can call get_column_letter() and pass it an integer like 27 to figure out what the letter name of the 27th
  column is. The function column_index_string() does the reverse: You pass it the letter name of a column, 
  and it tells you what number that column is. You don’t need to have a workbook loaded to use these functions.

----------------------------------------------------------------------------------------------------
	Getting rows and columns from the sheets
----------------------------------------------------------------------------------------------------

- You can slice Worksheet objects to get all the Cell objects in a row, column, or rectangular area of the
  spreadsheet. Then you can loop over all the cells in the slice.


----------------------------------------------------------------------------------------------------
	Writing excel documents
----------------------------------------------------------------------------------------------------

- OpenPyXL also provides ways of writing data, meaning that your programs can create and edit spreadsheet files. 

----------------------------------------------------------------------------------------------------
	Creating and saving excel documents
----------------------------------------------------------------------------------------------------

- Call the openpyxl.Workbook() function to create a new, blank Workbook object.
- Any time you modify the Workbook object or its sheets and cells, the spreadsheet file will not be saved
  until you call the save() workbook method.
- To save our changes, we pass a filename as a string to the save() method which is called on the workbook object.

- Whenever you edit a spreadsheet you’ve loaded from a file, you should always save the new, edited 
  spreadsheet to a different filename than the original. That way, you’ll still have the original spreadsheet
  file to work with in case a bug in your code caused the new, saved file to have incorrect or corrupt data.

----------------------------------------------------------------------------------------------------
	Creating and removing sheets
----------------------------------------------------------------------------------------------------

- Sheets can be added to and removed from a workbook with the create_sheet() and remove_sheet() methods. 
- The create_sheet() method returns a new Worksheet object named SheetX, which by default is set to be the last
  sheet in the workbook. Optionally, the index and name of the new sheet can be specified with 
  the index and title keyword arguments

----------------------------------------------------------------------------------------------------
	Writing values to cells
----------------------------------------------------------------------------------------------------

- Writing values to cells is much like writing values to keys in a dictionary. 
- If you have the cell’s coordinate as a string, you can use it just like a dictionary key on the Worksheet
  object to specify which cell to write to


----------------------------------------------------------------------------------------------------
	Setting font style of cells
----------------------------------------------------------------------------------------------------

- Styling certain cells, rows, or columns can help you emphasize important areas in your spreadsheet.
- To customize font styles in cells, important, import the Font() and Style() functions from the openpyxl.styles 
  module. 
  		from openpyxl.styles import Font, NamedStyle


----------------------------------------------------------------------------------------------------
	Formulas
----------------------------------------------------------------------------------------------------

- Formulas, which begin with an equal sign, can configure cells to contain values calculated from other cells.
	e.g sheet['B9'] = '=SUM(B1:B8)'
	     This will store =SUM(B1:B8) as the value in cell B9. This sets the B9 cell to a formula that 
             calculates the sum of values in cells B1 to B8.

- You can also read the formula in a cell just as you would any value. However, if you want to see the result 
  of the calculation for the formula instead of the literal formula, you must pass True for the data_only keyword 
  argument to load_workbook(). This means a Workbook object can show either the formulas or the result of the 
  formulas but not both. (But you can have multiple Workbook objects loaded for the same spreadsheet file.)


----------------------------------------------------------------------------------------------------
	Adjusting rows and columns
----------------------------------------------------------------------------------------------------

- In Excel, adjusting the sizes of rows and columns is as easy as clicking and dragging the edges of a row or column
  header. But if you need to set a row or column’s size based on its cells’ contents or if you want to set sizes in a 
  large number of spreadsheet files, it will be much quicker to write a Python program to do it.
- Rows and columns can also be hidden entirely from view. Or they can be “frozen” in place so that they are
  always visible on the screen and appear on every page when the spreadsheet is printed (which is handy for headers)

----------------------------------------------------------------------------------------------------
	Setting row height and column width
----------------------------------------------------------------------------------------------------
- Worksheet objects have row_dimensions and column_dimensions attributes that control row heights and column widths.

- A sheet’s row_dimensions and column_dimensions are dictionary-like values; row_dimensions contains 
  RowDimension objects and column_dimensions contains ColumnDimension objects. In row_dimensions, 
  you can access one of the objects using the number of the row (in this case, 1 or 2). In column_dimensions, 
  you can access one of the objects using the letter of the column (in this case, A or B).

- Once you have the RowDimension object, you can set its height. Once you have the ColumnDimension object, 
  you can set its width. The row height can be set to an integer or float value between 0 and 409. 
  This value represents the height measured in points, where one point equals 1/72 of an inch. The default row
  height is 12.75. The column width can be set to an integer or float value between 0 and 255. This value 
  represents the number of characters at the default font size (11 point) that can be displayed in the cell. 
  The default column width is 8.43 characters. Columns with widths of 0 or rows with heights of 0 are hidden from
  the user

----------------------------------------------------------------------------------------------------
	Merging and unmerging cells
----------------------------------------------------------------------------------------------------

- A rectangular area of cells can be merged into a single cell with the merge_cells() sheet method.
- The argument to merge_cells() is a single string of the top-left and bottomright cells of the rectangular 
  area to be merged: 'A1:D3' merges 12 cells into a single cell. To set the value of these merged cells, 
  simply set the value of the top-left cell of the merged group.

----------------------------------------------------------------------------------------------------
	Freeze panes
----------------------------------------------------------------------------------------------------

- For spreadsheets too large to be displayed all at once, it’s helpful to “freeze” a few of the top rows or 
  leftmost columns onscreen. Frozen column or row headers, for example, are always visible to the user even as 
  they scroll through the spreadsheet. These are known as freeze panes. In OpenPyXL, each Worksheet object has
  a freeze_panes attribute that can be set to a Cell object or a string of a cell’s coordinates. Note that all 
  rows above and all columns to the left of this cell will be frozen, but the row and column of the cell itself will not
  be frozen.
- To unfreeze all panes, set freeze_panes to None or 'A1'.

					Frozen Pane Examples
freeze_panes setting 						Rows and columns frozen
sheet.freeze_panes = 'A2' 					Row 1
sheet.freeze_panes = 'B1' 					Column A
sheet.freeze_panes = 'C1' 					Columns A and B
sheet.freeze_panes = 'C2' 					Row 1 and columns A and B
sheet.freeze_panes = 'A1' or sheet.freeze_panes = None 		No frozen panes


----------------------------------------------------------------------------------------------------
	Charts
----------------------------------------------------------------------------------------------------

- OpenPyXL supports creating bar, line, scatter, and pie charts using the data in a sheet’s cells. 
  To make a chart, you need to do the following:
1. Create a Reference object from a rectangular selection of cells.
2. Create a Series object by passing in the Reference object.
3. Create a Chart object.
4. Append the Series object to the Chart object.
5. Optionally, set the width and height variables of the Chart object.
6. Add the Chart object to the Worksheet object.

- Reference objects are created by calling the openpyxl.charts.Reference() function and passing three arguments:
1. The Worksheet object containing your chart data.
2. the min_col, min_row, max_col and max_row of the set of data you want to make a chart from.



----------------------------------------------------------------------------------------------------
	Working with PDF and word documents
----------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------
	PDF documents:
Extracting text from PDFs
----------------------------------------------------------------------------------------------------

- PDF stands for Portable Document Format and uses the .pdf file extension.
- PyPDF2 does not have a way to extract images, charts, or other media from PDF documents, but it can extract 
  text and return it as a Python string.

- First, import the PyPDF2 module. Then open the PDF file in read binary mode and store it in pdfFileObj. 
  To get a PdfFileReader object that represents this PDF, call PyPDF2.PdfFileReader() and pass it pdfFileObj. 
  Store this PdfFileReader object in pdfReader.

- The total number of pages in the document is stored in the numPages attribute of a PdfFileReader object. 

- To extract text from a page, you need to get a Page object, which represents a single page of a PDF, 
  from a PdfFileReader object. You can get a Page object by calling the getPage() method on a PdfFileReader 
  object and passing it the page number of the page you’re interested in.

- PyPDF2 uses a zero-based index for getting pages: The first page is page 0, the second is Introduction, 
  and so on. This is always the case, even if pages are numbered differently within the document. For example,
  say your PDF is a three-page excerpt from a longer report, and its pages are numbered 42, 43, and 44. To get the
  first page of this document, you would want to call pdfReader.getPage(0), not getPage(42) or getPage(1).

- Once you have your Page object, call its extractText() method to return a string of the page’s text

----------------------------------------------------------------------------------------------------
	Decrypting PDFs
----------------------------------------------------------------------------------------------------

- Some PDF documents have an encryption feature that will keep them from being read until whoever is opening the 
  document provides a password.

- All PdfFileReader objects have an isEncrypted attribute that is True if the PDF is encrypted and False if
  it isn’t. Any attempt to call a function that reads the file before it has been decrypted with the correct
  password will result in an error.

- To read an encrypted PDF, call the decrypt() function and pass the password as a string. After you call decrypt()
  with the correct password, you’ll see that calling getPage() no longer causes an error. If given the wrong password,
  the decrypt() function will return 0 and getPage() will continue to fail. Note that the decrypt() method 
  decrypts only the PdfFileReader object, not the actual PDF file. After your program terminates, the file on 
  your hard drive remains encrypted. Your program will have to call decrypt() again the next time it is run

----------------------------------------------------------------------------------------------------
	Creating PDFs
----------------------------------------------------------------------------------------------------

- PyPDF2’s counterpart to PdfFileReader objects is PdfFileWriter objects, which can create new PDF files. 
  But PyPDF2 cannot write arbitrary text to a PDF like Python can do with plaintext files. Instead, PyPDF2’s 
  PDF-writing capabilities are limited to copying pages from other PDFs, rotating pages, overlaying pages, 
  and encrypting files.
- PyPDF2 doesn’t allow you to directly edit a PDF. Instead, you have to create a new PDF and then copy content 
  over from an existing document.

1. Open one or more existing PDFs (the source PDFs) into PdfFileReader objects.
2. Create a new PdfFileWriter object.
3. Copy pages from the PdfFileReader objects into the PdfFileWriter object.
4. Finally, use the PdfFileWriter object to write the output PDF.

- Creating a PdfFileWriter object creates only a value that represents a PDF document in Python. It doesn’t create
  the actual PDF file. For that, you must call the PdfFileWriter’s write() method.
- The write() method takes a regular File object that has been opened in writebinary mode. You can get such a 
  File object by calling Python’s open() function with two arguments: the string of what you want the PDF’s 
  filename to be and 'wb' to indicate the file should be opened in write-binary mode.


----------------------------------------------------------------------------------------------------
	Copying pages
----------------------------------------------------------------------------------------------------

- You can use PyPDF2 to copy pages from one PDF document to another. This allows you to combine multiple 
  PDF files, cut unwanted pages, or reorder pages.
- the File object passed to PyPDF2.PdfFileReader() needs to be opened in read-binary mode by passing 'rb' 
  as the second argument to open(). Likewise, the File object passed to PyPDF2.PdfFileWriter() needs to be opened in
  write-binary mode with 'wb'.


----------------------------------------------------------------------------------------------------
	Rotating pages
----------------------------------------------------------------------------------------------------

- The pages of a PDF can also be rotated in 90-degree increments with the rotateClockwise() and rotateCounterClockwise()
  methods. Pass one of the integers 90, 180, or 270 to these methods. 


----------------------------------------------------------------------------------------------------
	Overlaying pages
----------------------------------------------------------------------------------------------------

- PyPDF2 can also overlay the contents of one page over another, which is useful for adding a logo, timestamp,
  or watermark to a page. With Python, it’s easy to add watermarks to multiple files and only to pages your 
  program specifies.


----------------------------------------------------------------------------------------------------
	Encrypting PDFs
----------------------------------------------------------------------------------------------------

- A PdfFileWriter object can also add encryption to a PDF document.

- Before calling the write() method to save to a file, call the encrypt() method and pass it a password string.
  PDFs can have a user password (allowing you to view the PDF) and an owner password (allowing you to set 
  permissions for printing, commenting, extracting text, and other features). The user password
  and owner password are the first and second arguments to encrypt(), respectively. If only one string
  argument is passed to encrypt(), it will be used for both passwords.



----------------------------------------------------------------------------------------------------
	Word documents	
----------------------------------------------------------------------------------------------------

- Compared to plaintext, .docx files have a lot of structure. This structure is represented by three different
  data types in Python-Docx. At the highest level, a Document object represents the entire document. The 
  Document object contains a list of Paragraph objects for the paragraphs in the document. (A new paragraph begins
  whenever the user presses ENTER or RETURN while typing in a Word document.) Each of these Paragraph objects 
  contains a list of one or more Run objects. 

- The text in a Word document is more than just a string. It has font, size, color, and other styling information 
  associated with it. A style in Word is a collection of these attributes. A Run object is a contiguous run of text 
  with the same style. A new Run object is needed whenever the text style changes.

----------------------------------------------------------------------------------------------------
	Reading word documents
----------------------------------------------------------------------------------------------------

- To open a .docx file in Python, call docx.Document(), and pass the filename. This will return a Document object,
  which has a paragraphs attribute that is a list of Paragraph objects. When we call len() on doc.paragraphs, it 
  returns the number of Paragraph objects in this document. Each of these Paragraph objects has a text attribute that
  contains a string of the text in that paragraph (without the style information). Here, the first text attribute 
  contains 'DocumentTitle', and the second contains 'A plain paragraph with some bold and some italic'.

- Each Paragraph object also has a runs attribute that is a list of Run objects. Run objects also have a text 
  attribute, containing just the text in that particular run.

----------------------------------------------------------------------------------------------------
	Getting the full text from a .docx file
----------------------------------------------------------------------------------------------------

- If you care only about the text, not the styling information, in the Word document, you can use the getText() 
  function. It accepts a filename of a .docx file and returns a single string value of its text. 

----------------------------------------------------------------------------------------------------
	Styling paragraphs and run objects
----------------------------------------------------------------------------------------------------

- In Word for Windows, you can see the styles by pressing CTRL-ALT-SHIFT-S to display the Styles pane

- Word and other word processors use styles to keep the visual presentation of similar types of text consistent
  and easy to change. For example, perhaps you want to set body paragraphs in 11-point, Times New Roman, left-justified,
  ragged-right text. You can create a style with these settings and assign it to all body paragraphs. Then, if you
  later want to change the presentation of all body paragraphs in the document, you can just change the style, and 
  all those paragraphs will be automatically updated
- For Word documents, there are three types of styles: Paragraph styles can be applied to Paragraph objects, 
  character styles can be applied to Run objects, and linked styles can be applied to both kinds of objects. 
  You can give both Paragraph and Run objects styles by setting their style attribute to a string. This string should
  be the name of a style. If style is set to None, then there will be no style associated with the Paragraph or 
  Run object.

The string values for the default Word styles are as follows:

'Normal' 	'Heading5' 	'ListBullet' 	'ListParagraph'
'BodyText' 	'Heading6' 	'ListBullet2' 	'MacroText'
'BodyText2' 	'Heading7' 	'ListBullet3' 	'NoSpacing'
'BodyText3' 	'Heading8' 	'ListContinue' 	'Quote'
'Caption' 	'Heading9' 	'ListContinue2' 'Subtitle'
'Heading1' 	'IntenseQuote' 	'ListContinue3' 'TOCHeading'
'Heading2' 	'List' 		'ListNumber' 	'Title'
'Heading3' 	'List2' 	'ListNumber2'
'Heading4' 	'List3' 	'ListNumber3

- When setting the style attribute, do not use spaces in the style name. For example, while the style name may be 
  Subtle Emphasis, you should set the style attribute to the string value 'SubtleEmphasis' instead of 'Subtle
  Emphasis'. Including spaces will cause Word to misread the style name and not apply it.

- When using a linked style for a Run object, you will need to add 'Char' to the end of its name. For example,  
  to set the Quote linked style for a Paragraph object, you would use paragraphObj.style = 'Quote',
  but for a Run object, you would use runObj.style = 'QuoteChar'.

----------------------------------------------------------------------------------------------------
	Creating word documents with non-default styles
----------------------------------------------------------------------------------------------------

- If you want to create Word documents that use styles beyond the default ones, you will need to open Word to a 
  blank Word document and create the styles yourself by clicking the New Style button at the bottom of the Styles pane
  This will open the Create New Style from Formatting dialog, where you can enter the new style. Then, go 
  back into the interactive shell and open this blank Word document with docx.Document(), using it as the base 
  for your Word document. The name you gave this style will now be available to use with Python-Docx.

----------------------------------------------------------------------------------------------------
	Run attributes
----------------------------------------------------------------------------------------------------

- Runs can be further styled using text attributes. Each attribute can be set to one of three values: 
  True (the attribute is always enabled, no matter what other styles are applied to the run), 
  False (the attribute is always disabled), or None (defaults to whatever the run’s style is set to).

					Run Object text Attributes
	Attribute 		Description
	bold 			The text appears in bold.
	italic 			The text appears in italic.
	underline 		The text is underlined.
	strike 			The text appears with strikethrough.
	double_strike 		The text appears with double strikethrough.
	all_caps 		The text appears in capital letters.
	small_caps 		The text appears in capital letters, with lowercase letters two points smaller.
	shadow 			The text appears with a shadow.
	outline 		The text appears outlined rather than solid.
	rtl 			The text is written right-to-left.
	imprint 		The text appears pressed into the page.
	emboss 			The text appears raised off the page in relief.

----------------------------------------------------------------------------------------------------
	writing word documents
----------------------------------------------------------------------------------------------------

- To create your own .docx file, call docx.Document() to return a new, blank Word Document object. The add_paragraph()
  document method adds a new paragraph of text to the document and returns a reference to the Paragraph object that
  was added. When you’re done adding text, pass a filename string to the save() document method to save the Document
  object to a file.
- You can add paragraphs by calling the add_paragraph() method again with the new paragraph’s text. Or to add text 
  to the end of an existing paragraph, you can call the paragraph’s add_run() method and pass it a string. 
- Keep in mind that new Paragraph objects can be added only to the end of the document, and new Run objects can be added
  only to the end of a Paragraph object.

----------------------------------------------------------------------------------------------------
	Adding headings
----------------------------------------------------------------------------------------------------

- Calling add_heading() adds a paragraph with one of the heading styles.

- The arguments to add_heading() are a string of the heading text and an integer from 0 to 4. The integer 0 makes
  the heading the Title style, which is used for the top of the document. Integers 1 to 4 are for various heading 
  levels, with 1 being the main heading and 4 the lowest subheading. The add_heading() function returns a Paragraph 
  object to save you the step of extracting it from the Document object as a separate step.

----------------------------------------------------------------------------------------------------
	Adding line and page breaks
----------------------------------------------------------------------------------------------------

- To add a line break (rather than starting a whole new paragraph), you can call the add_break() method on the Run 
  object you want to have the break appear after. If you want to add a page break instead, you need to pass the value
  docx.text.WD_BREAK.PAGE as a lone argument to add_break()

----------------------------------------------------------------------------------------------------
	Adding pictures
----------------------------------------------------------------------------------------------------

- Document objects have an add_picture() method that will let you add an image to the end of the document. 

- The first argument is a string of the image’s filename. The optional width and height keyword arguments will
  set the width and height of the image in the document. If left out, the width and height will default to the normal
  size of the image.
- You’ll probably prefer to specify an image’s height and width in familiar units such as inches and centimeters,
  so you can use the docx.shared.Inches() and docx.shared.Cm() functions when you’re specifying the width and height
  keyword arguments



*CHAPTER fourteen:
----------------------------------------------------------------------------------------------------
	Working with CSV Files and JSON Data
----------------------------------------------------------------------------------------------------

- CSV and JSON files are just plaintext files. You can view them in a text editor, such as IDLE’s file editor.\

- CSV stands for “comma-separated values,” and CSV files are simplified spreadsheets stored as plaintext files.
  Python’s csv module makes it easy to parse CSV files.
- JSON is a format that stores information as JavaScript source code in plaintext files. (JSON is short for 
  JavaScript Object Notation.) You don’t need to know the JavaScript programming language to use JSON files,
  but the JSON format is useful to know because it’s used in many web applications


----------------------------------------------------------------------------------------------------
	The CSV module
----------------------------------------------------------------------------------------------------

- Each line in a CSV file represents a row in the spreadsheet, and commas separate the cells in the row.

- The advantage of CSV files is simplicity. CSV files are widely supported by many types of programs, can be viewed 
  in text editors (including IDLE’s file editor), and are a straightforward way to represent spreadsheet data. The CSV
  format is exactly as advertised: It’s just a text file of comma-separated values.
- not every comma in a CSV file represents the boundary between two cells. CSV files also have their own set of 
  escape characters to allow commas and other characters to be included as part of the values. The 
  split() method doesn’t handle these escape characters.

----------------------------------------------------------------------------------------------------
	Reader objects
----------------------------------------------------------------------------------------------------

- To read data from a CSV file with the csv module, you need to create a Reader object. A Reader object lets you
  iterate over lines in the CSV file. 

- To read a CSV file with the csv module, first open it using the open() function, just as you would any other 
  text file. But instead of calling the read() or readlines() method on the File object that open() returns, 
  pass it to the csv.reader() function. This will return a Reader object for you to use. Note that you don’t pass a 
  filename string directly to the csv.reader() function. The most direct way to access the values in the Reader 
  object is to convert it to a plain Python list by passing it to list(). Using list() on this Reader object
  returns a list of lists, which you can store in a variable

- Now that you have the CSV file as a list of lists, you can access the value at a particular row and column with
  the expression exampleData[row][col], where row is the index of one of the lists in exampleData, and col is the index 
  of the item you want from that list. 

----------------------------------------------------------------------------------------------------
	Reading data from Reader objects in a for loop
----------------------------------------------------------------------------------------------------

- For large CSV files, you’ll want to use the Reader object in a for loop. This avoids loading the entire file
  into memory at once.

- After you import the csv module and make a Reader object from the CSV file, you can loop through the rows in 
  the Reader object. Each row is a list of values, with each value representing a cell. The print() function call 
  prints the number of the current row and the contents of the row. To get the row number, use the Reader object’s 
  line_num variable, which contains the number of the current line.
- The Reader object can be looped over only once. To reread the CSV file, you must call csv.reader to 
  create a Reader object

----------------------------------------------------------------------------------------------------
	Writer objects
----------------------------------------------------------------------------------------------------

- A Writer object lets you write data to a CSV file. To create a Writer object, you use the csv.writer() function.

- First, call open() and pass it 'w' to open a file in write mode. This will create the object you can then pass to 
  csv.writer() to create a Writer object. On Windows, you’ll also need to pass a blank string for the open() function’s
  newline keyword argument. if you forget to set the newline argument, the rows in output.csv will be double-spaced.

- The writerow() method for Writer objects takes a list argument. Each value in the list is placed in its own cell
  in the output CSV file. The return value of writerow() is the number of characters written to the file for that row
  (including newline characters).

----------------------------------------------------------------------------------------------------
	The delimiter and lineterminator Keyword Arguments
----------------------------------------------------------------------------------------------------

- This changes the delimiter and line terminator characters in your file. The delimiter is the character that 
  appears between cells on a row. By default, the delimiter for a CSV file is a comma. The line terminator is the
  character that comes at the end of a row. By default, the line terminator is a newline. You can change characters 
  to different values by using the delimiter and lineterminator keyword arguments with csv.writer().
- Now that our cells are separated by tabs, we’re using the file extension .tsv, for tab-separated values


----------------------------------------------------------------------------------------------------
	JSON and APIs
----------------------------------------------------------------------------------------------------

- JavaScript Object Notation is a popular way to format data as a single humanreadable string. JSON is the native
  way that JavaScript programs write their data structures and usually resembles what Python’s pprint() function would
  produce. 
- JSON is useful to know, because many websites offer JSON content as a way for programs to interact with the website.
  This is known as providing an application programming interface (API). Accessing an API is the same as accessing any
  other web page via a URL. The difference is that the data returned by an API is formatted (with JSON, for example)
  for machines; APIs aren’t easy for people to read.


----------------------------------------------------------------------------------------------------
	The JSON module
----------------------------------------------------------------------------------------------------

- Python’s json module handles all the details of translating between a string with JSON data and Python values
  for the json.loads() and json.dumps() functions. JSON can’t store every kind of Python value. It can contain values of
  only the following data types: strings, integers, floats, Booleans, lists, dictionaries, and NoneType. 
  JSON cannot represent Python-specific objects, such as File objects, CSV Reader or Writer objects, Regex objects, or
  Selenium WebElement objects

----------------------------------------------------------------------------------------------------
	Reading JSON with the loads() function
----------------------------------------------------------------------------------------------------

- To translate a string containing JSON data into a Python value, pass it to the json.loads() function. 
  (The name means “load string,” not “loads.”)
- After you import the json module, you can call loads() and pass it a string of JSON data. Note that JSON strings 
  always use double quotes. It will return that data as a Python dictionary. Python dictionaries are not ordered, 
  so the key-value pairs may appear in a different order when you print jsonDataAsPythonValue

----------------------------------------------------------------------------------------------------
	Writing JSON with the dumps() Function
----------------------------------------------------------------------------------------------------

- The json.dumps() function (which means “dump string,” not “dumps”) will translate a Python value into a string 
  of JSON-formatted data.


*CHAPTER Fifteen:  Keeping Time, Scheduling Tasks, and Launching Programs*
----------------------------------------------------------------------------------------------------
	The time module
----------------------------------------------------------------------------------------------------

- Your computer’s system clock is set to a specific date, time, and time zone. The built-in time module allows
  your Python programs to read the system clock for the current time.

----------------------------------------------------------------------------------------------------
	The time.time() function
----------------------------------------------------------------------------------------------------

- The Unix epoch is a time reference commonly used in programming: 12 AM on January 1, 1970, Coordinated Universal Time
  (UTC). The time.time() function returns the number of seconds since that moment as a float value. This number is 
  called an epoch timestamp. 
- Epoch timestamps can be used to profile code, that is, measure how long a piece of code takes to run. If you call 
  time.time() at the beginning of the code block you want to measure and again at the end, you can subtract the first 
  timestamp from the second to find the elapsed time between those two calls. 

----------------------------------------------------------------------------------------------------
	The time.sleep() function
----------------------------------------------------------------------------------------------------

- If you need to pause your program for a while, call the time.sleep() function and pass it the number of seconds
  you want your program to stay paused. 
- The time.sleep() function will block—that is, it will not return and release your program to execute other 
  code—until after the number of seconds you passed to time.sleep() has elapsed.
- Be aware that pressing CTRL-C will not interrupt time.sleep() calls in IDLE. IDLE waits until the entire pause
  is over before raising the KeyboardInterrupt exception. To work around this problem, instead of having a single
  time.sleep(30) call to pause for 30 seconds, use a for loop to make 30 calls to time.sleep(1).


----------------------------------------------------------------------------------------------------
	Rounding numbers
----------------------------------------------------------------------------------------------------

- When working with times, you’ll often encounter float values with many digits after the decimal. To make these
  values easier to work with, you can shorten them with Python’s built-in round() function, which rounds a float to
  the precision you specify. Just pass in the number you want to round, plus an optional second argument representing
  how many digits after the decimal point you want to round it to. If you omit the second argument, round() rounds your
  number to the nearest whole integer.


----------------------------------------------------------------------------------------------------
	The datetime module
----------------------------------------------------------------------------------------------------

- if you want to display a date in a more convenient format, or do arithmetic with dates  you should use the datetime
  module. The datetime module has its own datetime data type. datetime values represent a specific moment in time. 

- Calling datetime.datetime.now() returns a datetime object for the current date and time, according to your 
  computer’s clock. This object includes the year, month, day, hour, minute, second, and microsecond of the current
  moment. You can also retrieve a datetime object for a specific moment by using the datetime.datetime() function,
  passing it integers representing the year, month, day, hour, and second of the moment you want. These integers will
  be stored in the datetime object’s year, month, day, hour, minute, and second attributes.

- A Unix epoch timestamp can be converted to a datetime object with the datetime.datetime.fromtimestamp() 
  function. The date and time of the datetime object will be converted for the local time zone.

- datetime objects can be compared with each other using comparison operators to find out which one precedes the other.
  The later datetime object is the “greater” value.

----------------------------------------------------------------------------------------------------
	The timedelta data type
----------------------------------------------------------------------------------------------------

- The datetime module also provides a timedelta data type, which represents a duration of time rather than a 
  moment in time.

- To create a timedelta object, use the datetime.timedelta() function. The datetime.timedelta() function takes 
  keyword arguments weeks, days, hours, minutes, seconds, milliseconds, and microseconds. There is no month or year
  keyword argument because “a month” or “a year” is a variable amount of time depending on the particular month or year.
  A timedelta object has the total duration represented in days, seconds, and microseconds. These numbers are stored
  in the days, seconds, and microseconds attributes, respectively. The total_seconds() method will return the duration 
  in number of seconds alone. Passing a timedelta object to str() will return a nicely formatted, human-readable
  string representation of the object

- The arithmetic operators can be used to perform date arithmetic on datetime values

----------------------------------------------------------------------------------------------------
	converting datetime objects to strings
----------------------------------------------------------------------------------------------------

- Epoch timestamps and datetime objects aren’t very friendly to the human eye. Use the strftime() method to 
  display a datetime object as a string. (The f in the name of the strftime() function stands for format.)
  The strftime() method uses directives similar to Python’s string formatting.

					 strftime() Directives
	strftime 	directive Meaning
	%Y 		Year with century, as in '2014'
	%y 		Year without century, '00' to '99' (1970 to 2069)
	%m 		Month as a decimal number, '01' to '12'
	%B 		Full month name, as in 'November'
	%b 		Abbreviated month name, as in 'Nov'
	%d		 Day of the month, '01' to '31'
	%j		 Day of the year, '001' to '366'
	%w		 Day of the week, '0' (Sunday) to '6' (Saturday)
	%A 		Full weekday name, as in 'Monday'
	%a		 Abbreviated weekday name, as in 'Mon'
	%H		 Hour (24-hour clock), '00' to '23'
	%I		 Hour (12-hour clock), '01' to '12'
	%M		 Minute, '00' to '59'
	%S		 Second, '00' to '59'
	%p		 'AM' or 'PM'
	%%		 Literal '%' character
- Pass strrftime() a custom format string containing formatting directives (along with any desired slashes, colons, 
  and so on), and strftime() will return the datetime object’s information as a formatted string. 

----------------------------------------------------------------------------------------------------
	converting strings to datetime objects
----------------------------------------------------------------------------------------------------

- The strptime() function is the inverse of the strftime() method. A custom format string using the same
  directives as strftime() must be passed so that strptime() knows how to parse and understand the string. 
  (The p in the name of the strptime() function stands for parse.)


----------------------------------------------------------------------------------------------------
	multithreading
----------------------------------------------------------------------------------------------------
- Rather than having all of your code wait until the time.sleep() function finishes, you can execute the delayed
  or scheduled code in a separate thread using Python’s threading module. The separate thread will pause for the
  time.sleep calls. Meanwhile, your program can do other work in the original thread.
- To make a separate thread, you first need to make a Thread object by calling the threading.Thread() function.

- At, we define a function that we want to use in a new thread. To create a Thread object, we call threading.Thread() 
  and pass it the keyword argument target=takeANap. This means the function we want to call in the new thread
  is takeANap(). Notice that the keyword argument is target=takeANap, not target=takeANap(). This is because you want
  to pass the takeANap() function itself as the argument, not call takeANap() and pass its return value.

----------------------------------------------------------------------------------------------------
	Passing Arguments to the Thread’s Target Function
----------------------------------------------------------------------------------------------------

- If the target function you want to run in the new thread takes arguments, you can pass the target function’s 
  arguments to threading.Thread(). For example, say you wanted to run this print() call in its own thread:
		>>> print('Cats', 'Dogs', 'Frogs', sep=' & ')
		Cats & Dogs & Frogs
  This print() call has three regular arguments, 'Cats', 'Dogs', and 'Frogs', and one keyword argument, sep=' & '. 
  The regular arguments can be passed as a list to the args keyword argument in threading.Thread(). The keyword
  argument can be specified as a dictionary to the kwargs keyword argument in threading.Thread().

----------------------------------------------------------------------------------------------------
	concurrency issues
----------------------------------------------------------------------------------------------------

- You can easily create several new threads and have them all running at the same time. But multiple threads 
  can also cause problems called concurrency issues. These issues happen when threads read and write variables at 
  the same time, causing the threads to trip over each other. Concurrency issues can be hard to
  reproduce consistently, making them hard to debug.
- To avoid concurrency issues, never let multiple threads read or write the same variables. When you create a new
  Thread object, make sure its target function uses only local variables in that function. This will avoid 
  hard-to-debug concurrency issues in your programs.

* The main thread moves on as normal while the other threads we create download comics. But say there’s some code
  you don’t want to run in the main thread until all the threads have completed. Calling a Thread object’s 
  join() method will block until that thread has finished. By using a for loop to iterate over all the
  Thread objects in the downloadThreads list, the main thread can call the join() method on each of the other threads.


----------------------------------------------------------------------------------------------------
	launching other programs from python
----------------------------------------------------------------------------------------------------

- Your Python program can start other programs on your computer with the Popen() function in the built-in subprocess
  module. (The P in the name of the Popen() function stands for process.) If you have multiple instances of an
  application open, each of those instances is a separate process of the same program. For example, if you open 
  multiple windows of your web browser at the same time, each of those windows is a different process of the web browser
  program.

- Every process can have multiple threads. Unlike threads, a process cannot directly read and write another process’s
  variables. If you think of a multithreaded program as having multiple fingers following source code, then
  having multiple processes of the same program open is like having a friend with a separate copy of the program’s 
  source code. You are both independently executing the same program.

- The return value is a Popen object, which has two useful methods: poll() and wait(). You can think of the poll()
  method as asking your friend if she’s finished running the code you gave her. The poll() method will return 
  None if the process is still running at the time poll() is called. If the program has terminated, it will return 
  the process’s integer exit code. An exit code is used to indicate whether the process terminated without errors 
  (an exit code of 0) or whether an error caused the process to terminate (a nonzero exit code—generally
  1, but it may vary depending on the program).

- The wait() method is like waiting for your friend to finish working on her code before you keep working on yours. 
  The wait() method will block until the launched process has terminated. This is helpful if you want your program to
  pause until the user finishes with the other program. The return value of wait() is the process’s integer exit code.

----------------------------------------------------------------------------------------------------
	Passing command line arguements to Popen
----------------------------------------------------------------------------------------------------

- You can pass command line arguments to processes you create with Popen(). To do so, you pass a list as the sole
  argument to Popen(). The first string in this list will be the executable filename of the program you want to 
  launch; all the subsequent strings will be the command line arguments to pass to the program when it starts. In 
  effect, this list will be the value of sys.argv for the launched program. 
- Most applications with a graphical user  interface (GUI) don’t use command line arguments as extensively as command 
  line–based or terminal-based programs do. But most GUI applications will accept a single argument for a file that 
  the applications will immediately open when they start.

----------------------------------------------------------------------------------------------------
	Running other python scripts
----------------------------------------------------------------------------------------------------

- You can launch a Python script from Python just like any other application. You just have to pass the python.exe 
  executable to Popen() and the filename of the .py script you want to run as its argument.
- Pass Popen() a list containing a string of the Python executable’s path and a string of the script’s filename.
  If the script you’re launching needs command line arguments, add them to the list after the script’s filename.
- Unlike importing the Python program as a module, when your Python program launches another Python program, 
  the two are run in separate processes and will not be able to share each other’s variables

----------------------------------------------------------------------------------------------------
	Opening files with default application
----------------------------------------------------------------------------------------------------

- Double-clicking a .txt file on your computer will automatically launch the application associated with the .txt file
  extension. Your computer will have several of these file extension associations set up already. Python can also open
  files this way with Popen(). Each operating system has a program that performs the equivalent of doubleclicking a
  document file to open it. On Windows, this is the start program.



*CHAPTER Fifteen: 
----------------------------------------------------------------------------------------------------
	Sending email and text messages
----------------------------------------------------------------------------------------------------

- Much like HTTP is the protocol used by computers to send web pages across the Internet, Simple Mail Transfer
  Protocol (SMTP) is the protocol used for sending email. SMTP dictates how email messages should be formatted, 
  encrypted, and relayed between mail servers, and all the other details that your computer handles after you click Send.
- SMTP just deals with sending emails to others. A different protocol, called IMAP, deals with retrieving emails
  sent to you

----------------------------------------------------------------------------------------------------
	connecting to an SMTP server
----------------------------------------------------------------------------------------------------

- The domain name for the SMTP server will usually be the name of your email provider’s domain name, with smtp.
  in front of it. For example, Gmail’s SMTP server is at smtp.gmail.com. 
-  (The port is an integer value and will almost always be 587, which is used by the command encryption standard, TLS.)

					Email Providers and Their SMTP Servers
	Provider 		SMTP server domain name
	Gmail 			smtp.gmail.com
	Outlook.com/Hotmail.com smtp-mail.outlook.com
	Yahoo Mail 		smtp.mail.yahoo.com
	AT&T 			smpt.mail.att.net (port 465)
	Comcast 		smtp.comcast.net
	Verizon 		smtp.verizon.net (port 465)

- Once you have the domain name and port information for your email provider, create an SMTP object by calling
  smptlib.SMTP(), passing the domain name as a string argument, and passing the port as an integer argument. 
  The SMTP object represents a connection to an SMTP mail server and has methods for sending emails.
- Sending the SMTP “Hello” Message Once you have the SMTP object, call its oddly named ehlo() method to “say hello” 
  to the SMTP email server. This greeting is the first step in SMTP and is important for establishing a connection 
  to the server or else the later method calls will result in errors.
- If the first item in the returned tuple is the integer 250 (the code for “success” in SMTP), then the greeting
  succeeded
- If you are connecting to port 587 on the SMTP server (that is, you’re using TLS encryption), you’ll need to call
  the starttls() method next. This required step enables encryption for your connection. If you are connecting to
  port 465 (using SSL), then encryption is already set up, and you should skip this step.
- starttls() puts your SMTP connection in TLS mode. The 220 in the return value tells you that the server is ready

- Once your encrypted connection to the SMTP server is set up, you can log in with your username 
  (usually your email address) and email password by calling the login() method

bajtcryceihnsxuj

----------------------------------------------------------------------------------------------------
	sending an email
----------------------------------------------------------------------------------------------------
- Once you are logged in to your email provider’s SMTP server, you can call the sendmail() method to actually 
  send the email.

- The sendmail() method requires three arguments. 
. Your email address as a string (for the email’s “from” address)
. The recipient’s email address as a string or a list of strings for multiple recipients (for the “to” address)
. The email body as a string

- The start of the email body string must begin with 'Subject: \n' for the subject line of the email. The '\n' 
  newline character separates the subject line from the main body of the email. The return value from sendmail()
  is a dictionary. There will be one key-value pair in the dictionary for each recipient for whom email delivery failed.
  An empty dictionary means all recipients were successfully sent the emai

* Be sure to call the quit() method when you are done sending emails. This will disconnect your program from the SMTP
  server.


----------------------------------------------------------------------------------------------------
	IMAP
----------------------------------------------------------------------------------------------------

- Just as SMTP is the protocol for sending email, the Internet Message Access Protocol (IMAP) specifies how to
  communicate with an email provider’s server to retrieve emails sent to your email address.

----------------------------------------------------------------------------------------------------
	connecting to an IMAP server
----------------------------------------------------------------------------------------------------

- Just like you needed an SMTP object to connect to an SMTP server and send email, you need an IMAPClient object
  to connect to an IMAP server and receive email. First you’ll need the domain name of your email provider’s IMAP server

					Email Providers and Their IMAP Servers
	Provider 		IMAP server domain name
	Gmail		 	imap.gmail.com
	Outlook.com/Hotmail.com imap-mail.outlook.com
	Yahoo Mail 		imap.mail.yahoo.com
	AT&T 			imap.mail.att.net
	Comcast 		imap.comcast.net
	Verizon 		incoming.verizon.net

- Once you have the domain name of the IMAP server, call the imapclient.IMAPClient() function to create an
  IMAPClient object. Most email providers require SSL encryption, so pass the ssl=True keyword argument.
* a client is the object that connects to the server.

----------------------------------------------------------------------------------------------------
	searching for email
----------------------------------------------------------------------------------------------------

- Once you’re logged on, actually retrieving an email that you’re interested in is a two-step process. 
  First, you must select a folder you want to search through. Then, you must call the IMAPClient object’s search()
  method, passing in a string of IMAP search keywords.
- you can also get a list of folders by calling the IMAPClient object’s list_folders() method. This returns a list
  of tuples. Each tuple contains information about a single folder.

-  (Gmail calls its folders labels, but they work the same way as folders.) The three values
in each of the tuples —are as follows:
. A tuple of the folder’s flags.
. The delimiter used in the name string to separate parent folders and subfolders.
. The full name of the folder

- To select a folder to search through, pass the folder’s name as a string into the IMAPClient object’s select_folder()

- The readonly=True keyword argument prevents you from accidentally making changes or deletions to any of the emails
  in this folder during the subsequent method calls. Unless you want to delete emails, it’s a good idea to always set
  readonly to True.

- With a folder selected, you can now search for emails with the IMAPClient object’s search() method. 
  The argument to search() is a list of strings, each formatted to the IMAP’s search keys.
- some IMAP servers may have slightly different implementations for how they handle their flags and search keys.
  It may require some experimentation in the interactive shell to see exactly how they behave
- You can pass multiple IMAP search key strings in the list argument to the search() method. The messages returned 
  are the ones that match all the search keys. If you want to match any of the search keys, use the OR search key. 
  For the NOT and OR search keys, one and two complete search keys follow the NOT and OR, respectively.

- search() method calls along with their meanings:
- imapObj.search(['ALL']). Returns every message in the currently selected folder.
- imapObj.search(['ON', '05-Jul-2015']). Returns every message sent on July 5, 2015.
- imapObj.search(['SINCE', '01-Jan-2015', 'BEFORE 01-Feb-2015', 'UNSEEN']). Returns every message sent in January 2015
  that is unread. (Note that this means on and after January 1 and up to but not including February 1.)
- imapObj.search(['SINCE', '01-Jan-2015', 'FROM alice@example.com']). Returns every message from alice@example.com
  sent since the start of 2015.
- imapObj.search(['SINCE', '01-Jan-2015', 'NOT FROM', 'alice@example.com']). Returns every message sent from everyone except
  alice@example.com since the start of 2015.
- imapObj.search(['OR FROM', 'alice@example.com 'FROM', bob@example.com']). Returns every message ever sent from
  alice@example.com or bob@example.com.
* imapObj.search(['FROM alice@example.com', 'FROM bob@example.com']). Trick example! This search will never return any
  messages, because messages must match all search keywords. Since there can be only one “from” address, it 
  is impossible for a message to be from both alice@example.com and bob@example.com.

- The search() method doesn’t return the emails themselves but rather unique IDs (UIDs) for the emails, as integer
  values. You can then pass these UIDs to the fetch() method to obtain the email content.

- If you are logging in to a Gmail account, pass the search terms to the gmail_search() method instead of the
  search() method

----------------------------------------------------------------------------------------------------
	Fetching an Email and Marking It As Read
----------------------------------------------------------------------------------------------------

- Once you have a list of UIDs, you can call the IMAPClient object’s fetch() method to get the actual email content.
  The list of UIDs will be fetch()’s first argument. The second argument should be the list ['BODY[]'], 
  which tells fetch() to download all the body content for the emails specified in your UID list.

- Import pprint and pass the return value from fetch(), stored in the variable rawMessages, to pprint.pprint() 
  to “pretty print” it, and you’ll see that this return value is a nested dictionary of messages with UIDs as the keys. 
  Each message is stored as a dictionary with two keys: 'BODY[]' and 'SEQ'. The 'BODY[]' key maps to the actual
  body of the email. The 'SEQ' key is for a sequence number, which has a similar role to the UID. 

- When you selected a folder to search through, you called select_folder() with the readonly=True keyword argument.
  Doing this will prevent you from accidentally deleting an email—but it also means that emails will not get marked
  as read if you fetch them with the fetch() method. If you do want emails to be marked as read when you fetch them,
  you will need to pass readonly=False to select_folder(). If the selected folder is already in readonly mode, you can
  reselect the current folder with another call to select_folder(), this time with the readonly=False keyword argument
 
----------------------------------------------------------------------------------------------------
	Getting Email Addresses from a Raw Message
----------------------------------------------------------------------------------------------------

- The pyzmail module parses these raw messages and returns them as PyzMessage objects, which make the subject,
  body, “To” field, “From” field, and other sections of the email easily accessible to your Python code.

- First, import pyzmail. Then, to create a PyzMessage object of an email, call the pyzmail.PyzMessage.factory()
  function and pass it the 'BODY[]' section of the raw message. Store the result in message. Now message contains a
  PyzMessage object, which has several methods that make it easy to get the email’s subject line, as well as all
  sender and recipient addresses. The get_subject() method returns the subject as a simple string value. The
  get_addresses() method returns a list of addresses for the field you pass it. 

- that the argument for get_addresses() is 'from', 'to', 'cc', or 'bcc'. The return value of get_addresses() is a
  list of tuples. Each tuple contains two strings: The first is the name associated with the email address, and
  the second is the email address itself. If there are no addresses in the requested field, get_addresses()
  returns a blank list. Here, the 'cc' carbon copy and 'bcc' blind carbon copy fields both contained no addresses 
  and so returned empty lists.

----------------------------------------------------------------------------------------------------
	Getting the Body from a Raw Message
----------------------------------------------------------------------------------------------------

- Emails can be sent as plaintext, HTML, or both. Plaintext emails contain only text, while HTML emails can have
  colors, fonts, images, and other features that make the email message look like a small web page. If an email is 
  only plaintext, its PyzMessage object will have its html_part attributes set to None. Likewise, if an email is 
  only HTML, its PyzMessage object will have its text_part attribute set to None.
- Otherwise, the text_part or html_part value will have a get_payload() method that returns the email’s body as 
  a value of the bytes data type. The last step is to call the decode() method on the bytes value returned by
  get_payload(). The decode() method takes one argument: the message’s character encoding, stored in the 
  text_part.charset or html_part.charset attribute. This, finally, will return the string of the email’s
  body.

----------------------------------------------------------------------------------------------------
	Deleting Emails
----------------------------------------------------------------------------------------------------

- To delete emails, pass a list of message UIDs to the IMAPClient object’s delete_messages() method. This marks
  the emails with the \Deleted flag. Calling the expunge() method will permanently delete all emails with the
  \Deleted flag in the currently selected folder


----------------------------------------------------------------------------------------------------
	sending text messages with twilio
----------------------------------------------------------------------------------------------------

- Twilio is an SMS gateway service, which means it’s a service that allows you to send text messages from your programs.



*CHAPTER SEVENTEEN: Manipulating images *
----------------------------------------------------------------------------------------------------
	Colors and RGBA values 
----------------------------------------------------------------------------------------------------

- Computer programs often represent a color in an image as an RGBA value. An RGBA value is a group of numbers
  that specify the amount of red, green, blue, and alpha (or transparency) in a color. Each of these component
  values is an integer from 0 (none at all) to 255 (the maximum). 
- These RGBA values are assigned to individual pixels; a pixel is the smallest dot of a single color the
  computer screen can show.
-  A pixel’s RGB setting tells it precisely what shade of color it should display. Images also have an alpha value
  to create RGBA values. If an image is displayed on the screen over a background image or desktop wallpaper, the
  alpha value determines how much of the background you can “see through” the image’s pixel.

				Standard Color Names and Their RGBA Values
	Name 	RGBA Value 		Name 	RGBA Value
	White 	(255, 255, 255, 255) 	Red 	(255, 0, 0, 255)
	Green 	(0, 128, 0, 255) 	Blue 	(0, 0, 255, 255)
	Gray 	(128, 128, 128, 255) 	Yellow 	(255, 255, 0, 255)
	Black 	(0, 0, 0, 255) 		Purple 	(128, 0, 128, 255)

- Pillow offers the ImageColor.getcolor() function so you don’t have to memorize RGBA values for the colors you want
  to use. This function takes a color name string as its first argument, and the string 'RGBA' as its second
  argument, and it returns an RGBA tuple.

----------------------------------------------------------------------------------------------------
	Coordinates and box tuples
----------------------------------------------------------------------------------------------------

- image pixels are addressed with x-and y-coordinates, which respectively specify a pixel’s horizontal and vertical
  location in an image. The origin is the pixel at the top-left corner of the image and is specified with the notation
  (0, 0). The first zero represents the x-coordinate, which starts at zero at the origin and increases going from 
  left to right. The second zero represents the y-coordinate, which starts at zero at the origin and increases
  going down the image. 
- Many of Pillow’s functions and methods take a box tuple argument. This means Pillow is expecting a tuple of four 
  integer coordinates that represent a rectangular region in an image. The four integers are, in order, as follows:
. Left: The x-coordinate of the leftmost edge of the box.
. Top: The y-coordinate of the top edge of the box.
. Right: The x-coordinate of one pixel to the right of the rightmost edge of the box. This integer must be greater 
  than the left integer.
. Bottom: The y-coordinate of one pixel lower than the bottom edge of the box. This integer must be greater than 
  the top integer.

----------------------------------------------------------------------------------------------------
	Working with the image data type
----------------------------------------------------------------------------------------------------

- An Image object has several useful attributes that give you basic information about the image file it was 
  loaded from: its width and height, the filename, and the graphics format (such as JPEG, GIF, or PNG).
- Pillow also provides the Image.new() function, which returns an Image object —much like Image.open(), except 
  the image represented by Image.new()’s object will be blank.
  The arguments to Image.new() are as follows:
. The string 'RGBA', which sets the color mode to RGBA.
. The size, as a two-integer tuple of the new image’s width and height.
. The background color that the image should start with, as a four-integer tuple of an RGBA value. You can use the 
  return value of the ImageColor.getcolor() function for this argument. Alternatively, Image.new() also supports 
  just passing the string of the standard color name.

----------------------------------------------------------------------------------------------------
	cropping images
----------------------------------------------------------------------------------------------------

- Cropping an image means selecting a rectangular region inside an image and removing everything outside the rectangle.
  The crop() method on Image objects takes a box tuple and returns an Image object representing the cropped image. 
  The cropping does not happen in place—that is, the original Image object is left untouched, and the crop() 
  method returns a new Image object

----------------------------------------------------------------------------------------------------
	Copying and Pasting Images onto Other Images
----------------------------------------------------------------------------------------------------

- The copy() method will return a new Image object with the same image as the Image object it was called on.
  This is useful if you need to make changes to an image but also want to keep an untouched version of the original.

- The paste() method is called on an Image object and pastes another image on top of it.
- The paste() method takes two arguments: a “source” Image object and a tuple of the x-and y-coordinates where 
  you want to paste the top-left corner of the source Image object onto the main Image object.
- Note that the paste() method modifies its Image object in place; it does not return an Image object with the pasted
  image. If you want to call paste() but also keep an untouched version of the original image around, you’ll need to 
  first copy the image and then call paste() on that copy.
*  if you want to paste an image that has transparent pixels, pass the Image object again as the third argument

----------------------------------------------------------------------------------------------------
	resizing an image
----------------------------------------------------------------------------------------------------

- The resize() method is called on an Image object and returns a new Image object of the specified width and height.
  It accepts a two-integer tuple argument, representing the new width and height of the returned image. 

----------------------------------------------------------------------------------------------------
	rotating and flipping images
----------------------------------------------------------------------------------------------------

- Images can be rotated with the rotate() method, which returns a new Image object of the rotated image and leaves
  the original Image object unchanged. The argument to rotate() is a single integer or float representing the number of
  degrees to rotate the image counterclockwise.
- The rotate() method has an optional expand keyword argument that can be set to True to enlarge the dimensions
  of the image to fit the entire rotated new image
- You can also get a “mirror flip” of an image with the transpose() method. You must pass either Image.FLIP_LEFT_RIGHT
  or Image.FLIP_TOP_BOTTOM to the transpose() method.

----------------------------------------------------------------------------------------------------
	changing individual pixels
----------------------------------------------------------------------------------------------------

- The color of an individual pixel can be retrieved or set with the getpixel() and putpixel() methods. These 
  methods both take a tuple representing the x-and ycoordinates of the pixel. The putpixel() method also takes
  an additional tuple argument for the color of the pixel. This color argument is a four-integer RGBA
  tuple or a three-integer RGB tuple.


----------------------------------------------------------------------------------------------------
	Drawing on images
----------------------------------------------------------------------------------------------------

- If you need to draw lines, rectangles, circles, or other simple shapes on an image, use Pillow’s ImageDraw module. 

- points - The point(xy, fill) method draws individual pixels. The xy argument represents a list of the points you 
  want to draw. The list can be a list of x-and ycoordinate tuples, such as [(x, y), (x, y), ...], or a list 
  of x-and ycoordinates without tuples, such as [x1, y1, x2, y2, ...]. The fill argument is the color of the points
  and is either an RGBA tuple or a string of a color name, such as 'red'. The fill argument is optional.
- Lines - The line(xy, fill, width) method draws a line or series of lines. xy is either a list of tuples, such 
  as [(x, y), (x, y), ...], or a list of integers, such as [x1, y1, x2, y2, ...]. Each point is one of the connecting 
  points on the lines you’re drawing. The optional fill argument is the color of the lines, as an RGBA tuple or color
  name. The optional width argument is the width of the lines and defaults to 1 if left unspecified.
- rectangles - The rectangle(xy, fill, outline) method draws a rectangle. The xy argument is a box tuple of the form
  (left, top, right, bottom). The left and top values specify the x-and y-coordinates of the upper-left corner of the
  rectangle, while right and bottom specify the lower-right corner. The optional fill argument is the color that 
  will fill the inside of the rectangle. The optional outline argument is the color of the rectangle’s outline.
- The ellipse(xy, fill, outline) method draws an ellipse. If the width and height of the ellipse are identical, 
  this method will draw a circle. The xy argument is a box tuple (left, top, right, bottom) that represents a box that
  precisely contains the ellipse. The optional fill argument is the color of the inside of the ellipse, and the 
  optional outline argument is the color of the ellipse’s outline.
- Polygons - The polygon(xy, fill, outline) method draws an arbitrary polygon. The xy argument is a list of tuples,
  such as [(x, y), (x, y), ...], or integers, such as [x1, y1, x2, y2, ...], representing the connecting points of the
  polygon’s sides. The last pair of coordinates will be automatically connected to the first pair. The optional 
  fill argument is the color of the inside of the polygon, and the optional outline argument is the color of the 
  polygon’s outline.

----------------------------------------------------------------------------------------------------
	Drawing text
----------------------------------------------------------------------------------------------------

- The ImageDraw object also has a text() method for drawing text onto an image. The text() method takes four arguments: 
  xy, text, fill, and font.
. The xy argument is a two-integer tuple specifying the upper-left corner of the text box.
. The text argument is the string of text you want to write.
. The optional fill argument is the color of the text.
. The optional font argument is an ImageFont object, used to set the typeface and size of the text. 

- Since it’s often hard to know in advance what size a block of text will be in a given font, the ImageDraw module
  also offers a textsize() method. Its first argument is the string of text you want to measure, and its second 
  argument is an optional ImageFont object. The textsize() method will then return a twointeger tuple of the 
  width and height that the text in the given font would be if it were written onto the image. You can use this width
  and height to help you calculate exactly where you want to put the text on your image.


*CHAPTER ONE:  Controlling the Keyboard and Mouse with GUI Automation*
----------------------------------------------------------------------------------------------------
	Pauses and FailSafes
----------------------------------------------------------------------------------------------------

- You can tell your script to wait after every function call, giving you a short window to take control of the mouse
  and keyboard if something goes wrong. To do this, set the pyautogui.PAUSE variable to the number of seconds you 
  want it to pause. For example, after setting pyautogui.PAUSE = 1.5, every PyAutoGUI function call will wait one and
  a half seconds after performing its action. Non-PyAutoGUI instructions will not have this pause.

- PyAutoGUI also has a fail-safe feature. Moving the mouse cursor to the upperleft corner of the screen will cause 
  PyAutoGUI to raise the pyautogui.FailSafeException exception. The fail-safe feature will stop the program if you 
  quickly move the mouse as far up and left as you can. You can disable this feature by setting 
  pyautogui.FAILSAFE = False.


----------------------------------------------------------------------------------------------------
	Controlling Mouse Movement
----------------------------------------------------------------------------------------------------

- Your resolution is how many pixels wide and tall your screen is. If your screen’s resolution is set to 1920×1080,
  then the coordinate for the upper-left corner will be (0, 0), and the coordinate for the bottom-right corner will be
  (1919, 1079). The pyautogui.size() function returns a two-integer tuple of the screen’s width and height in pixels.

----------------------------------------------------------------------------------------------------
	Moving the mouse
----------------------------------------------------------------------------------------------------

- The pyautogui.moveTo() function will instantly move the mouse cursor to a specified position on the screen. 
  Integer values for the x-and y-coordinates make up the function’s first and second arguments, respectively. 
  An optional duration integer or float keyword argument specifies the number of seconds it should take to move the
  mouse to the destination. If you leave it out, the default is 0 for instantaneous movement. (All of the duration
  keyword arguments in PyAutoGUI functions are optional.)
- The pyautogui.moveRel() function moves the mouse cursor relative to its current position.
- A negative integer for the first or second argument will cause the mouse to move left or upward, respectively

----------------------------------------------------------------------------------------------------
	Getting the mouse position
----------------------------------------------------------------------------------------------------

- You can determine the mouse’s current position by calling the pyautogui.position() function, which will return a 
  tuple of the mouse cursor’s x and y positions at the time of the function call.

**** always pass flush=True to print() calls that print \b backspace characters. Otherwise, the screen might
  not update the text as desired.****

----------------------------------------------------------------------------------------------------
	clicking the mouse
----------------------------------------------------------------------------------------------------

- To send a virtual mouse click to your computer, call the pyautogui.click() method. By default, this click uses the
  left mouse button and takes place wherever the mouse cursor is currently located. You can pass x-and y
  coordinates of the click as optional first and second arguments if you want it to take place somewhere other
  than the mouse’s current position.
- If you want to specify which mouse button to use, include the button keyword argument, with a value of 'left', 
 'middle', or 'right'. For example, pyautogui.click(100, 150, button='left') will click the left mouse
  button at the coordinates (100, 150)
- As a further convenience, the pyautogui.doubleClick() function will perform two clicks with the left mouse button

----------------------------------------------------------------------------------------------------
	Dragging the mouse
----------------------------------------------------------------------------------------------------

- PyAutoGUI provides the pyautogui.dragTo() and pyautogui.dragRel() functions to drag the mouse cursor to a new 
  location or a location relative to its current one. The arguments for dragTo() and dragRel() are the same as
  moveTo() and moveRel(). (OS X does not drag correctly when the mouse moves too quickly, so passing a duration
  keyword argument is recommended.)

----------------------------------------------------------------------------------------------------
	scrolling the mouse
----------------------------------------------------------------------------------------------------

- The final PyAutoGUI mouse function is scroll(), which you pass an integer argument for how many units you want to
  scroll the mouse up or down. The size of a unit varies for each operating system and application, so you’ll have to
  experiment to see exactly how far it scrolls in your particular situation. The scrolling takes place at the mouse 
  cursor’s current position. Passing a positive integer scrolls up, and passing a negative integer scrolls down.


----------------------------------------------------------------------------------------------------
	working with the screen
----------------------------------------------------------------------------------------------------

- PyAutoGUI has screenshot features that can create an image file based on the current contents of the screen. 
  These functions can also return a Pillow Image object of the current screen’s appearance. 
- To take screenshots in Python, call the pyautogui.screenshot() function.
- The im variable will contain the Image object of the screenshot. You can now call methods on the Image object in the
  im variable, just like any other Image object.
  ***  There is no fourth value for alpha, because screenshot images are fully opaque.

----------------------------------------------------------------------------------------------------
	Analysing the screenshot
----------------------------------------------------------------------------------------------------

- PyAutoGUI’s pixelMatchesColor() function will return True if the pixel at the given x-and y-coordinates on the screen
  matches the given color. The first and second arguments are integers for the x-and y-coordinates, and the third
  argument is a tuple of three integers for the RGB color the screen pixel must match.

- Note that the color at the given coordinates must exactly match. If it is even slightly different, then 
  pixelMatchesColor() will return False


----------------------------------------------------------------------------------------------------
	Image recognition
----------------------------------------------------------------------------------------------------

- The four-integer tuple that locateOnScreen() returns has the x-coordinate of the left edge, the y-coordinate of the
  top edge, the width, and the height for the first place on the screen the image was found.
- If the image can be found in several places on the screen, locateAllOnScreen() will return a Generator object, 
  which can be passed to list() to return a list of four-integer tuples. There will be one four-integer tuple
  for each location where the image is found on the screen.

- Once you have the four-integer tuple for the area on the screen where your image was found, you can click the
  center of this area by passing the tuple to the center() function to return x-and y-coordinates of the area’s center.


----------------------------------------------------------------------------------------------------
	Controlling the keyboard: sending a string from the keyboard
----------------------------------------------------------------------------------------------------

- The pyautogui.typewrite() function sends virtual keypresses to the computer. What these keypresses do depends on
  what window and text field have focus.

- By default, the typewrite() function will type the full string instantly. However, you can pass an optional second
  argument to add a short pause between each character. This second argument is an integer or float value of the
  number of seconds to pause. For example, pyautogui.typewrite('Hello world!', 0.25) will wait a quarter-second 
  after typing H, another quartersecond after e, and so on. This gradual typewriter effect may be useful for slower
  applications that can’t process keystrokes fast enough to keep up with PyAutoGUI.
- For characters such as A or !, PyAutoGUI will automatically simulate holding down the SHIFT key as well.

----------------------------------------------------------------------------------------------------
	Hot key combinations
----------------------------------------------------------------------------------------------------

- use the pyautogui.hotkey() function, which takes multiple keyboard key string arguments, presses them in order, and
  releases them in the reverse order.


----------------------------------------------------------------------------------------------------
	CLASSES
----------------------------------------------------------------------------------------------------

- classes in python should begin with capital letters
- A function that’s part of a class is a method. 
- The __init__() method at w is a special method Python runs automatically whenever we create a new instance based on the class.

- The self parameter is required in the method definition, and it must come first before the other parameters. It must be included in the definition because when Python calls this __init__() method later (to create an instance of Dog), the method call will automatically pass the self argument. Every method call associated with a class automatically passes self, which is a reference to the instance itself; it gives the individual instance access to the attributes and methods in the class.

- if the class you’re writing is a specialized version of another class you wrote, you can use inheritance. When one class inherits from another, it automatically takes on all the attributes and methods of the first class. The original class is called the parent class, and the new class is the child class. The child class inherits every attribute and method from its parent class but is also free to define new attributes and methods of its own.


- When you create a child class, the parent class must be part of the current file and must appear before the child
class in the file.
- The super() function at is a special function that helps Python make connections between the parent and child class. This line tells Python to call the __init__() method from the parent class, which gives the child class instance all the attributes of its parent class. The name supercomes from a convention of calling the parent class a superclass and the 
child class a subclass.

- You can override any method from the parent class that doesn’t fit what you’re trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Python will disregard the parent class method and only pay attention to the method you define in the child class.